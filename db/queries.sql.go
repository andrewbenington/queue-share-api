// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package db

import (
	"context"
	"time"

	uuid "github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const albumCacheGetByID = `-- name: AlbumCacheGetByID :many
SELECT
    id, uri, name, artist_id, artist_uri, artist_name, album_group, album_type, image_url, release_date, release_date_precision, genres, popularity, upc, spotify_track_ids, track_isrcs
FROM
    SPOTIFY_ALBUM_CACHE
WHERE
    id = ANY ($1::text[])
`

func (q *Queries) AlbumCacheGetByID(ctx context.Context, albumIds []string) ([]*AlbumData, error) {
	rows, err := q.db.Query(ctx, albumCacheGetByID, albumIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*AlbumData
	for rows.Next() {
		var i AlbumData
		if err := rows.Scan(
			&i.ID,
			&i.URI,
			&i.Name,
			&i.ArtistID,
			&i.ArtistURI,
			&i.ArtistName,
			&i.AlbumGroup,
			&i.AlbumType,
			&i.ImageUrl,
			&i.ReleaseDate,
			&i.ReleaseDatePrecision,
			&i.Genres,
			&i.Popularity,
			&i.Upc,
			&i.SpotifyTrackIds,
			&i.TrackIsrcs,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const albumCacheInsertBulk = `-- name: AlbumCacheInsertBulk :exec
INSERT INTO SPOTIFY_ALBUM_CACHE(
    id,
    uri,
    name,
    artist_id,
    artist_uri,
    artist_name,
    album_group,
    album_type,
    image_url,
    release_date,
    release_date_precision,
    genres,
    popularity)
VALUES (
    unnest(
        $1 ::text[]),
    unnest(
        $2 ::text[]),
    unnest(
        $3 ::text[]),
    unnest(
        $4 ::text[]),
    unnest(
        $5 ::text[]),
    unnest(
        $6 ::text[]),
    unnest(
        $7 ::text[]),
    unnest(
        $8 ::text[]),
    unnest(
        $9 ::text[]),
    unnest(
        $10 ::date[]),
    unnest(
        $11 ::text[]),
    unnest(
        $12 ::jsonb[]),
    unnest(
        $13 ::int[]))
ON CONFLICT
    DO NOTHING
`

type AlbumCacheInsertBulkParams struct {
	ID                   []string      `json:"id"`
	URI                  []string      `json:"uri"`
	Name                 []string      `json:"name"`
	ArtistID             []string      `json:"artist_id"`
	ArtistURI            []string      `json:"artist_uri"`
	ArtistName           []string      `json:"artist_name"`
	AlbumGroup           []string      `json:"album_group"`
	AlbumType            []string      `json:"album_type"`
	ImageUrl             []string      `json:"image_url"`
	ReleaseDate          []pgtype.Date `json:"release_date"`
	ReleaseDatePrecision []string      `json:"release_date_precision"`
	Genres               [][]byte      `json:"genres"`
	Popularity           []int32       `json:"popularity"`
}

func (q *Queries) AlbumCacheInsertBulk(ctx context.Context, arg AlbumCacheInsertBulkParams) error {
	_, err := q.db.Exec(ctx, albumCacheInsertBulk,
		arg.ID,
		arg.URI,
		arg.Name,
		arg.ArtistID,
		arg.ArtistURI,
		arg.ArtistName,
		arg.AlbumGroup,
		arg.AlbumType,
		arg.ImageUrl,
		arg.ReleaseDate,
		arg.ReleaseDatePrecision,
		arg.Genres,
		arg.Popularity,
	)
	return err
}

const albumCacheInsertOne = `-- name: AlbumCacheInsertOne :exec
INSERT INTO SPOTIFY_ALBUM_CACHE(
    id,
    uri,
    name,
    artist_id,
    artist_uri,
    artist_name,
    album_group,
    album_type,
    image_url,
    release_date,
    release_date_precision,
    genres,
    popularity,
    upc,
    spotify_track_ids,
    track_isrcs)
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12,
    $13,
    $14,
    $15,
    $16)
`

type AlbumCacheInsertOneParams struct {
	ID                   string     `json:"id"`
	URI                  string     `json:"uri"`
	Name                 string     `json:"name"`
	ArtistID             string     `json:"artist_id"`
	ArtistURI            string     `json:"artist_uri"`
	ArtistName           string     `json:"artist_name"`
	AlbumGroup           *string    `json:"album_group"`
	AlbumType            *string    `json:"album_type"`
	ImageUrl             *string    `json:"image_url"`
	ReleaseDate          *time.Time `json:"release_date"`
	ReleaseDatePrecision *string    `json:"release_date_precision"`
	Genres               []string   `json:"genres"`
	Popularity           *int32     `json:"popularity"`
	Upc                  *string    `json:"upc"`
	SpotifyTrackIds      []string   `json:"spotify_track_ids"`
	TrackIsrcs           []string   `json:"track_isrcs"`
}

func (q *Queries) AlbumCacheInsertOne(ctx context.Context, arg AlbumCacheInsertOneParams) error {
	_, err := q.db.Exec(ctx, albumCacheInsertOne,
		arg.ID,
		arg.URI,
		arg.Name,
		arg.ArtistID,
		arg.ArtistURI,
		arg.ArtistName,
		arg.AlbumGroup,
		arg.AlbumType,
		arg.ImageUrl,
		arg.ReleaseDate,
		arg.ReleaseDatePrecision,
		arg.Genres,
		arg.Popularity,
		arg.Upc,
		arg.SpotifyTrackIds,
		arg.TrackIsrcs,
	)
	return err
}

const albumCacheUpdateOne = `-- name: AlbumCacheUpdateOne :exec
UPDATE
    SPOTIFY_ALBUM_CACHE
SET
    name = $1,
    image_url = $2,
    genres = $3,
    popularity = $4,
    upc = $5,
    spotify_track_ids = $6,
    track_isrcs = $7
WHERE
    id = $8
`

type AlbumCacheUpdateOneParams struct {
	Name            string   `json:"name"`
	ImageUrl        *string  `json:"image_url"`
	Genres          []string `json:"genres"`
	Popularity      *int32   `json:"popularity"`
	Upc             *string  `json:"upc"`
	SpotifyTrackIds []string `json:"spotify_track_ids"`
	TrackIsrcs      []string `json:"track_isrcs"`
	ID              string   `json:"id"`
}

func (q *Queries) AlbumCacheUpdateOne(ctx context.Context, arg AlbumCacheUpdateOneParams) error {
	_, err := q.db.Exec(ctx, albumCacheUpdateOne,
		arg.Name,
		arg.ImageUrl,
		arg.Genres,
		arg.Popularity,
		arg.Upc,
		arg.SpotifyTrackIds,
		arg.TrackIsrcs,
		arg.ID,
	)
	return err
}

const artistCacheGetByID = `-- name: ArtistCacheGetByID :many
SELECT
    id, uri, name, image_url, genres, popularity, follower_count
FROM
    SPOTIFY_ARTIST_CACHE
WHERE
    id = ANY ($1::text[])
`

func (q *Queries) ArtistCacheGetByID(ctx context.Context, artistIds []string) ([]*ArtistData, error) {
	rows, err := q.db.Query(ctx, artistCacheGetByID, artistIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ArtistData
	for rows.Next() {
		var i ArtistData
		if err := rows.Scan(
			&i.ID,
			&i.URI,
			&i.Name,
			&i.ImageUrl,
			&i.Genres,
			&i.Popularity,
			&i.FollowerCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const artistCacheGetPresentIDs = `-- name: ArtistCacheGetPresentIDs :many
SELECT
    id
FROM
    SPOTIFY_ARTIST_CACHE
WHERE
    id = ANY ($1::text[])
`

func (q *Queries) ArtistCacheGetPresentIDs(ctx context.Context, artistIds []string) ([]string, error) {
	rows, err := q.db.Query(ctx, artistCacheGetPresentIDs, artistIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

type ArtistCacheInsertBulkParams struct {
	ID            string   `json:"id"`
	URI           string   `json:"uri"`
	Name          string   `json:"name"`
	ImageUrl      *string  `json:"image_url"`
	Genres        []string `json:"genres"`
	Popularity    *int32   `json:"popularity"`
	FollowerCount *int32   `json:"follower_count"`
}

const artistCacheInsertOne = `-- name: ArtistCacheInsertOne :exec
INSERT INTO SPOTIFY_ARTIST_CACHE(
    id,
    uri,
    name,
    image_url,
    genres,
    popularity,
    follower_count)
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7)
`

type ArtistCacheInsertOneParams struct {
	ID            string   `json:"id"`
	URI           string   `json:"uri"`
	Name          string   `json:"name"`
	ImageUrl      *string  `json:"image_url"`
	Genres        []string `json:"genres"`
	Popularity    *int32   `json:"popularity"`
	FollowerCount *int32   `json:"follower_count"`
}

func (q *Queries) ArtistCacheInsertOne(ctx context.Context, arg ArtistCacheInsertOneParams) error {
	_, err := q.db.Exec(ctx, artistCacheInsertOne,
		arg.ID,
		arg.URI,
		arg.Name,
		arg.ImageUrl,
		arg.Genres,
		arg.Popularity,
		arg.FollowerCount,
	)
	return err
}

const artistCacheUpdateOne = `-- name: ArtistCacheUpdateOne :exec
UPDATE
    SPOTIFY_ARTIST_CACHE
SET
    name = $1,
    image_url = $2,
    genres = $3,
    popularity = $4,
    follower_count = $5
WHERE
    id = $6
`

type ArtistCacheUpdateOneParams struct {
	Name          string   `json:"name"`
	ImageUrl      *string  `json:"image_url"`
	Genres        []string `json:"genres"`
	Popularity    *int32   `json:"popularity"`
	FollowerCount *int32   `json:"follower_count"`
	ID            string   `json:"id"`
}

func (q *Queries) ArtistCacheUpdateOne(ctx context.Context, arg ArtistCacheUpdateOneParams) error {
	_, err := q.db.Exec(ctx, artistCacheUpdateOne,
		arg.Name,
		arg.ImageUrl,
		arg.Genres,
		arg.Popularity,
		arg.FollowerCount,
		arg.ID,
	)
	return err
}

const getSpotifyTokensByRoomCode = `-- name: GetSpotifyTokensByRoomCode :one
SELECT
    st.encrypted_access_token,
    st.access_token_expiry,
    st.encrypted_refresh_token
FROM
    spotify_tokens AS st
    JOIN rooms AS r ON r.code = $1
        AND st.user_id = r.host_id
`

type GetSpotifyTokensByRoomCodeRow struct {
	EncryptedAccessToken  []byte    `json:"encrypted_access_token"`
	AccessTokenExpiry     time.Time `json:"access_token_expiry"`
	EncryptedRefreshToken []byte    `json:"encrypted_refresh_token"`
}

func (q *Queries) GetSpotifyTokensByRoomCode(ctx context.Context, code string) (*GetSpotifyTokensByRoomCodeRow, error) {
	row := q.db.QueryRow(ctx, getSpotifyTokensByRoomCode, code)
	var i GetSpotifyTokensByRoomCodeRow
	err := row.Scan(&i.EncryptedAccessToken, &i.AccessTokenExpiry, &i.EncryptedRefreshToken)
	return &i, err
}

const historyGetAlbumStreamCountByYear = `-- name: HistoryGetAlbumStreamCountByYear :many
SELECT
    album_name,
    COUNT(*) AS occurrences
FROM
    spotify_history
WHERE
    user_id = $1
    AND ms_played >= $2
    AND timestamp BETWEEN ($3::int || '-01-01 00:00:00')::timestamp AND (cast((($3::int) + 1) AS text) || '-01-01 00:00:00')::timestamp
GROUP BY
    album_name
ORDER BY
    COUNT(*) DESC
LIMIT 35
`

type HistoryGetAlbumStreamCountByYearParams struct {
	UserID      uuid.UUID `json:"user_id"`
	MinMsPlayed int32     `json:"min_ms_played"`
	Year        int32     `json:"year"`
}

type HistoryGetAlbumStreamCountByYearRow struct {
	AlbumName   string `json:"album_name"`
	Occurrences int64  `json:"occurrences"`
}

func (q *Queries) HistoryGetAlbumStreamCountByYear(ctx context.Context, arg HistoryGetAlbumStreamCountByYearParams) ([]*HistoryGetAlbumStreamCountByYearRow, error) {
	rows, err := q.db.Query(ctx, historyGetAlbumStreamCountByYear, arg.UserID, arg.MinMsPlayed, arg.Year)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*HistoryGetAlbumStreamCountByYearRow
	for rows.Next() {
		var i HistoryGetAlbumStreamCountByYearRow
		if err := rows.Scan(&i.AlbumName, &i.Occurrences); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const historyGetAlbumStreams = `-- name: HistoryGetAlbumStreams :many
WITH SongStreamCounts AS (
    SELECT
        spotify_album_uri,
        spotify_artist_uri,
        spotify_track_uri,
        COUNT(*) AS stream_count
    FROM
        spotify_history
    WHERE
        user_id = $1
        AND spotify_album_uri = ANY ($2::text[])
    GROUP BY
        spotify_album_uri,
        spotify_artist_uri,
        spotify_track_uri
),
RankedStreams AS (
    SELECT
        spotify_album_uri,
        spotify_artist_uri,
        spotify_track_uri,
        stream_count,
        ROW_NUMBER() OVER (PARTITION BY spotify_album_uri ORDER BY stream_count DESC) AS rank
    FROM
        SongStreamCounts
)
SELECT
    spotify_album_uri,
    spotify_artist_uri,
    spotify_track_uri,
    stream_count
FROM
    RankedStreams
WHERE
    rank <= 10
ORDER BY
    spotify_album_uri,
    rank
`

type HistoryGetAlbumStreamsParams struct {
	UserID    uuid.UUID `json:"user_id"`
	AlbumUris []string  `json:"album_uris"`
}

type HistoryGetAlbumStreamsRow struct {
	SpotifyAlbumUri  *string `json:"spotify_album_uri"`
	SpotifyArtistUri *string `json:"spotify_artist_uri"`
	SpotifyTrackUri  string  `json:"spotify_track_uri"`
	StreamCount      int64   `json:"stream_count"`
}

func (q *Queries) HistoryGetAlbumStreams(ctx context.Context, arg HistoryGetAlbumStreamsParams) ([]*HistoryGetAlbumStreamsRow, error) {
	rows, err := q.db.Query(ctx, historyGetAlbumStreams, arg.UserID, arg.AlbumUris)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*HistoryGetAlbumStreamsRow
	for rows.Next() {
		var i HistoryGetAlbumStreamsRow
		if err := rows.Scan(
			&i.SpotifyAlbumUri,
			&i.SpotifyArtistUri,
			&i.SpotifyTrackUri,
			&i.StreamCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const historyGetAll = `-- name: HistoryGetAll :many
SELECT
    TIMESTAMP,
    TRACK_NAME,
    h.ARTIST_NAME,
    h.album_name,
    MS_PLAYED,
    spotify_track_uri,
    spotify_album_uri,
    spotify_artist_uri,
    image_url,
    other_artists,
    h.isrc
FROM
    SPOTIFY_HISTORY h
    JOIN SPOTIFY_TRACK_CACHE ON URI = spotify_track_uri
WHERE
    user_id = $1
    AND ms_played >= $2
    AND ($3::timestamp IS NULL
        OR $4::timestamp IS NULL
        OR timestamp BETWEEN $3::timestamp AND $4::timestamp)
ORDER BY
    timestamp DESC
LIMIT $5
`

type HistoryGetAllParams struct {
	UserID      uuid.UUID  `json:"user_id"`
	MinMsPlayed int32      `json:"min_ms_played"`
	StartDate   *time.Time `json:"start_date"`
	EndDate     *time.Time `json:"end_date"`
	MaxCount    int32      `json:"max_count"`
}

type HistoryGetAllRow struct {
	Timestamp        time.Time    `json:"timestamp"`
	TrackName        string       `json:"track_name"`
	ArtistName       string       `json:"artist_name"`
	AlbumName        string       `json:"album_name"`
	MsPlayed         int32        `json:"ms_played"`
	SpotifyTrackUri  string       `json:"spotify_track_uri"`
	SpotifyAlbumUri  *string      `json:"spotify_album_uri"`
	SpotifyArtistUri *string      `json:"spotify_artist_uri"`
	ImageUrl         *string      `json:"image_url"`
	OtherArtists     TrackArtists `json:"other_artists"`
	Isrc             *string      `json:"isrc"`
}

func (q *Queries) HistoryGetAll(ctx context.Context, arg HistoryGetAllParams) ([]*HistoryGetAllRow, error) {
	rows, err := q.db.Query(ctx, historyGetAll,
		arg.UserID,
		arg.MinMsPlayed,
		arg.StartDate,
		arg.EndDate,
		arg.MaxCount,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*HistoryGetAllRow
	for rows.Next() {
		var i HistoryGetAllRow
		if err := rows.Scan(
			&i.Timestamp,
			&i.TrackName,
			&i.ArtistName,
			&i.AlbumName,
			&i.MsPlayed,
			&i.SpotifyTrackUri,
			&i.SpotifyAlbumUri,
			&i.SpotifyArtistUri,
			&i.ImageUrl,
			&i.OtherArtists,
			&i.Isrc,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const historyGetArtistStreamCountByYear = `-- name: HistoryGetArtistStreamCountByYear :many
SELECT
    artist_name,
    COUNT(*) AS occurrences
FROM
    spotify_history
WHERE
    user_id = $1
    AND ms_played >= $2
    AND timestamp BETWEEN ($3::int || '-01-01 00:00:00')::timestamp AND (cast((($3::int) + 1) AS text) || '-01-01 00:00:00')::timestamp
GROUP BY
    artist_name
ORDER BY
    COUNT(*) DESC
LIMIT 35
`

type HistoryGetArtistStreamCountByYearParams struct {
	UserID      uuid.UUID `json:"user_id"`
	MinMsPlayed int32     `json:"min_ms_played"`
	Year        int32     `json:"year"`
}

type HistoryGetArtistStreamCountByYearRow struct {
	ArtistName  string `json:"artist_name"`
	Occurrences int64  `json:"occurrences"`
}

func (q *Queries) HistoryGetArtistStreamCountByYear(ctx context.Context, arg HistoryGetArtistStreamCountByYearParams) ([]*HistoryGetArtistStreamCountByYearRow, error) {
	rows, err := q.db.Query(ctx, historyGetArtistStreamCountByYear, arg.UserID, arg.MinMsPlayed, arg.Year)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*HistoryGetArtistStreamCountByYearRow
	for rows.Next() {
		var i HistoryGetArtistStreamCountByYearRow
		if err := rows.Scan(&i.ArtistName, &i.Occurrences); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const historyGetByAlbumURI = `-- name: HistoryGetByAlbumURI :many
SELECT
    TIMESTAMP,
    TRACK_NAME,
    ARTIST_NAME,
    album_name,
    MS_PLAYED,
    spotify_track_uri,
    spotify_artist_uri,
    spotify_album_uri
FROM
    SPOTIFY_HISTORY
WHERE
    user_id = $1
    AND ms_played >= $2
    AND spotify_album_uri = $3
ORDER BY
    timestamp ASC
`

type HistoryGetByAlbumURIParams struct {
	UserID      uuid.UUID `json:"user_id"`
	MinMsPlayed int32     `json:"min_ms_played"`
	URI         *string   `json:"uri"`
}

type HistoryGetByAlbumURIRow struct {
	Timestamp        time.Time `json:"timestamp"`
	TrackName        string    `json:"track_name"`
	ArtistName       string    `json:"artist_name"`
	AlbumName        string    `json:"album_name"`
	MsPlayed         int32     `json:"ms_played"`
	SpotifyTrackUri  string    `json:"spotify_track_uri"`
	SpotifyArtistUri *string   `json:"spotify_artist_uri"`
	SpotifyAlbumUri  *string   `json:"spotify_album_uri"`
}

func (q *Queries) HistoryGetByAlbumURI(ctx context.Context, arg HistoryGetByAlbumURIParams) ([]*HistoryGetByAlbumURIRow, error) {
	rows, err := q.db.Query(ctx, historyGetByAlbumURI, arg.UserID, arg.MinMsPlayed, arg.URI)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*HistoryGetByAlbumURIRow
	for rows.Next() {
		var i HistoryGetByAlbumURIRow
		if err := rows.Scan(
			&i.Timestamp,
			&i.TrackName,
			&i.ArtistName,
			&i.AlbumName,
			&i.MsPlayed,
			&i.SpotifyTrackUri,
			&i.SpotifyArtistUri,
			&i.SpotifyAlbumUri,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const historyGetByArtistURI = `-- name: HistoryGetByArtistURI :many
SELECT
    sh.TIMESTAMP,
    sh.TRACK_NAME,
    sh.album_name,
    sh.MS_PLAYED,
    sh.spotify_track_uri,
    sh.spotify_album_uri,
    tc.isrc
FROM
    SPOTIFY_HISTORY sh
    JOIN SPOTIFY_TRACK_CACHE tc ON sh.spotify_track_uri = tc.uri
        AND user_id = $1
        AND ms_played >= $2
        AND spotify_artist_uri = $3
    ORDER BY
        timestamp ASC
`

type HistoryGetByArtistURIParams struct {
	UserID      uuid.UUID `json:"user_id"`
	MinMsPlayed int32     `json:"min_ms_played"`
	URI         *string   `json:"uri"`
}

type HistoryGetByArtistURIRow struct {
	Timestamp       time.Time `json:"timestamp"`
	TrackName       string    `json:"track_name"`
	AlbumName       string    `json:"album_name"`
	MsPlayed        int32     `json:"ms_played"`
	SpotifyTrackUri string    `json:"spotify_track_uri"`
	SpotifyAlbumUri *string   `json:"spotify_album_uri"`
	Isrc            *string   `json:"isrc"`
}

func (q *Queries) HistoryGetByArtistURI(ctx context.Context, arg HistoryGetByArtistURIParams) ([]*HistoryGetByArtistURIRow, error) {
	rows, err := q.db.Query(ctx, historyGetByArtistURI, arg.UserID, arg.MinMsPlayed, arg.URI)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*HistoryGetByArtistURIRow
	for rows.Next() {
		var i HistoryGetByArtistURIRow
		if err := rows.Scan(
			&i.Timestamp,
			&i.TrackName,
			&i.AlbumName,
			&i.MsPlayed,
			&i.SpotifyTrackUri,
			&i.SpotifyAlbumUri,
			&i.Isrc,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const historyGetByTrackURI = `-- name: HistoryGetByTrackURI :many
SELECT
    TIMESTAMP,
    h.TRACK_NAME,
    h.ARTIST_NAME,
    h.album_name,
    MS_PLAYED,
    spotify_track_uri,
    spotify_artist_uri,
    spotify_album_uri,
    tc1.isrc
FROM
    SPOTIFY_HISTORY h
    JOIN spotify_track_cache tc1 ON tc1.uri = $1
    JOIN spotify_track_cache tc2 ON tc2.isrc = tc1.isrc
WHERE
    user_id = $2
    AND ms_played >= $3
    AND h.spotify_track_uri = tc2.uri
ORDER BY
    timestamp ASC
`

type HistoryGetByTrackURIParams struct {
	URI         string    `json:"uri"`
	UserID      uuid.UUID `json:"user_id"`
	MinMsPlayed int32     `json:"min_ms_played"`
}

type HistoryGetByTrackURIRow struct {
	Timestamp        time.Time `json:"timestamp"`
	TrackName        string    `json:"track_name"`
	ArtistName       string    `json:"artist_name"`
	AlbumName        string    `json:"album_name"`
	MsPlayed         int32     `json:"ms_played"`
	SpotifyTrackUri  string    `json:"spotify_track_uri"`
	SpotifyArtistUri *string   `json:"spotify_artist_uri"`
	SpotifyAlbumUri  *string   `json:"spotify_album_uri"`
	Isrc             *string   `json:"isrc"`
}

func (q *Queries) HistoryGetByTrackURI(ctx context.Context, arg HistoryGetByTrackURIParams) ([]*HistoryGetByTrackURIRow, error) {
	rows, err := q.db.Query(ctx, historyGetByTrackURI, arg.URI, arg.UserID, arg.MinMsPlayed)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*HistoryGetByTrackURIRow
	for rows.Next() {
		var i HistoryGetByTrackURIRow
		if err := rows.Scan(
			&i.Timestamp,
			&i.TrackName,
			&i.ArtistName,
			&i.AlbumName,
			&i.MsPlayed,
			&i.SpotifyTrackUri,
			&i.SpotifyArtistUri,
			&i.SpotifyAlbumUri,
			&i.Isrc,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const historyGetNewArtists = `-- name: HistoryGetNewArtists :many
WITH all_artists AS (
    SELECT
        spotify_artist_uri,
        count(*),
        array_agg(DISTINCT date(timestamp))::text[] AS distinct_dates
    FROM
        spotify_history h1
    WHERE
        h1.user_id = $1
        AND h1.timestamp >= $2::timestamp
        AND h1.timestamp < $3::timestamp
    GROUP BY
        spotify_artist_uri
),
new_this_month AS (
    SELECT
        spotify_artist_uri, count, distinct_dates
    FROM
        all_artists aa
    WHERE
        NOT EXISTS (
            SELECT
                1
            FROM
                spotify_history h2
            WHERE
                h2.user_id = $1
                AND timestamp < $2::timestamp
                AND h2.spotify_artist_uri = aa.spotify_artist_uri))
SELECT
    TRIM(LEADING 'spotify:artist:' FROM spotify_artist_uri)::text AS id,
    count,
    distinct_dates
FROM
    new_this_month
WHERE
    count > 5
    AND array_length(distinct_dates, 1) > 1
LIMIT 100
`

type HistoryGetNewArtistsParams struct {
	UserID    uuid.UUID `json:"user_id"`
	StartDate time.Time `json:"start_date"`
	EndDate   time.Time `json:"end_date"`
}

type HistoryGetNewArtistsRow struct {
	ID            string   `json:"id"`
	Count         int64    `json:"count"`
	DistinctDates []string `json:"distinct_dates"`
}

func (q *Queries) HistoryGetNewArtists(ctx context.Context, arg HistoryGetNewArtistsParams) ([]*HistoryGetNewArtistsRow, error) {
	rows, err := q.db.Query(ctx, historyGetNewArtists, arg.UserID, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*HistoryGetNewArtistsRow
	for rows.Next() {
		var i HistoryGetNewArtistsRow
		if err := rows.Scan(&i.ID, &i.Count, &i.DistinctDates); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const historyGetRecentArtistStreams = `-- name: HistoryGetRecentArtistStreams :many
WITH SongStreamCounts AS (
    SELECT
        spotify_artist_uri,
        spotify_track_uri,
        COUNT(*) AS stream_count
    FROM
        spotify_history
    WHERE
        user_id = $1
        AND spotify_artist_uri = ANY ($2::text[])
        AND timestamp >= CURRENT_DATE - INTERVAL '6 months'
    GROUP BY
        spotify_artist_uri,
        spotify_track_uri
),
RankedStreams AS (
    SELECT
        spotify_artist_uri,
        spotify_track_uri,
        stream_count,
        ROW_NUMBER() OVER (PARTITION BY spotify_artist_uri ORDER BY stream_count DESC) AS rank
    FROM
        SongStreamCounts
)
SELECT
    spotify_artist_uri,
    spotify_track_uri,
    stream_count
FROM
    RankedStreams
WHERE
    rank <= 10
ORDER BY
    spotify_artist_uri,
    rank
`

type HistoryGetRecentArtistStreamsParams struct {
	UserID     uuid.UUID `json:"user_id"`
	ArtistUris []string  `json:"artist_uris"`
}

type HistoryGetRecentArtistStreamsRow struct {
	SpotifyArtistUri *string `json:"spotify_artist_uri"`
	SpotifyTrackUri  string  `json:"spotify_track_uri"`
	StreamCount      int64   `json:"stream_count"`
}

func (q *Queries) HistoryGetRecentArtistStreams(ctx context.Context, arg HistoryGetRecentArtistStreamsParams) ([]*HistoryGetRecentArtistStreamsRow, error) {
	rows, err := q.db.Query(ctx, historyGetRecentArtistStreams, arg.UserID, arg.ArtistUris)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*HistoryGetRecentArtistStreamsRow
	for rows.Next() {
		var i HistoryGetRecentArtistStreamsRow
		if err := rows.Scan(&i.SpotifyArtistUri, &i.SpotifyTrackUri, &i.StreamCount); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const historyGetTimestampRange = `-- name: HistoryGetTimestampRange :one
SELECT
    MIN(timestamp)::timestamp AS first,
    MAX(timestamp)::timestamp AS last
FROM
    spotify_history
WHERE
    user_id = $1
`

type HistoryGetTimestampRangeRow struct {
	First time.Time `json:"first"`
	Last  time.Time `json:"last"`
}

func (q *Queries) HistoryGetTimestampRange(ctx context.Context, userID uuid.UUID) (*HistoryGetTimestampRangeRow, error) {
	row := q.db.QueryRow(ctx, historyGetTimestampRange, userID)
	var i HistoryGetTimestampRangeRow
	err := row.Scan(&i.First, &i.Last)
	return &i, err
}

const historyGetTopAlbumsInTimeframe = `-- name: HistoryGetTopAlbumsInTimeframe :many
SELECT
    spotify_album_uri,
    COUNT(*) AS occurrences,
    json_agg(spotify_track_uri) AS TRACKS
FROM
    spotify_history
WHERE
    user_id = $1
    AND ms_played >= $2
    AND timestamp BETWEEN $3::timestamp AND $4::timestamp
    AND ($5::text IS NULL
        OR spotify_artist_uri = $5::text)
GROUP BY
    spotify_album_uri
ORDER BY
    COUNT(*) DESC
LIMIT $6
`

type HistoryGetTopAlbumsInTimeframeParams struct {
	UserID      uuid.UUID `json:"user_id"`
	MinMsPlayed int32     `json:"min_ms_played"`
	StartDate   time.Time `json:"start_date"`
	EndDate     time.Time `json:"end_date"`
	ArtistURI   *string   `json:"artist_uri"`
	Max         int32     `json:"max"`
}

type HistoryGetTopAlbumsInTimeframeRow struct {
	SpotifyAlbumUri *string `json:"spotify_album_uri"`
	Occurrences     int64   `json:"occurrences"`
	Tracks          []byte  `json:"tracks"`
}

func (q *Queries) HistoryGetTopAlbumsInTimeframe(ctx context.Context, arg HistoryGetTopAlbumsInTimeframeParams) ([]*HistoryGetTopAlbumsInTimeframeRow, error) {
	rows, err := q.db.Query(ctx, historyGetTopAlbumsInTimeframe,
		arg.UserID,
		arg.MinMsPlayed,
		arg.StartDate,
		arg.EndDate,
		arg.ArtistURI,
		arg.Max,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*HistoryGetTopAlbumsInTimeframeRow
	for rows.Next() {
		var i HistoryGetTopAlbumsInTimeframeRow
		if err := rows.Scan(&i.SpotifyAlbumUri, &i.Occurrences, &i.Tracks); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const historyGetTopAlbumsNotInCache = `-- name: HistoryGetTopAlbumsNotInCache :many
SELECT
    SPOTIFY_ALBUM_URI,
    COUNT(SPOTIFY_ALBUM_URI)
FROM
    spotify_history h
    LEFT JOIN spotify_album_cache ac ON h.spotify_album_uri = ac.uri
WHERE
    ac.uri IS NULL
GROUP BY
    SPOTIFY_ALBUM_URI
ORDER BY
    COUNT DESC
LIMIT 50
`

type HistoryGetTopAlbumsNotInCacheRow struct {
	SpotifyAlbumUri *string `json:"spotify_album_uri"`
	Count           int64   `json:"count"`
}

func (q *Queries) HistoryGetTopAlbumsNotInCache(ctx context.Context) ([]*HistoryGetTopAlbumsNotInCacheRow, error) {
	rows, err := q.db.Query(ctx, historyGetTopAlbumsNotInCache)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*HistoryGetTopAlbumsNotInCacheRow
	for rows.Next() {
		var i HistoryGetTopAlbumsNotInCacheRow
		if err := rows.Scan(&i.SpotifyAlbumUri, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const historyGetTopArtistsInTimeframe = `-- name: HistoryGetTopArtistsInTimeframe :many
SELECT
    spotify_artist_uri,
    COUNT(*) AS occurrences,
    json_agg(spotify_track_uri) AS TRACKS
FROM
    spotify_history
WHERE
    user_id = $1
    AND ms_played >= $2
    AND timestamp BETWEEN $3::timestamp AND $4::timestamp
GROUP BY
    spotify_artist_uri
ORDER BY
    COUNT(*) DESC
LIMIT $5
`

type HistoryGetTopArtistsInTimeframeParams struct {
	UserID      uuid.UUID `json:"user_id"`
	MinMsPlayed int32     `json:"min_ms_played"`
	StartDate   time.Time `json:"start_date"`
	EndDate     time.Time `json:"end_date"`
	Max         int32     `json:"max"`
}

type HistoryGetTopArtistsInTimeframeRow struct {
	SpotifyArtistUri *string `json:"spotify_artist_uri"`
	Occurrences      int64   `json:"occurrences"`
	Tracks           []byte  `json:"tracks"`
}

func (q *Queries) HistoryGetTopArtistsInTimeframe(ctx context.Context, arg HistoryGetTopArtistsInTimeframeParams) ([]*HistoryGetTopArtistsInTimeframeRow, error) {
	rows, err := q.db.Query(ctx, historyGetTopArtistsInTimeframe,
		arg.UserID,
		arg.MinMsPlayed,
		arg.StartDate,
		arg.EndDate,
		arg.Max,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*HistoryGetTopArtistsInTimeframeRow
	for rows.Next() {
		var i HistoryGetTopArtistsInTimeframeRow
		if err := rows.Scan(&i.SpotifyArtistUri, &i.Occurrences, &i.Tracks); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const historyGetTopTracksInTimeframe = `-- name: HistoryGetTopTracksInTimeframe :many
SELECT
    spotify_track_uri,
    COUNT(*) AS occurrences
FROM
    spotify_history
WHERE
    user_id = $1
    AND ms_played >= $2
    AND timestamp BETWEEN $3::timestamp AND $4::timestamp
    AND ($5::text[] IS NULL
        OR spotify_artist_uri = ANY ($5::text[]))
    AND ($6::text IS NULL
        OR spotify_album_uri = $6::text)
GROUP BY
    spotify_track_uri
ORDER BY
    COUNT(*) DESC
LIMIT $7
`

type HistoryGetTopTracksInTimeframeParams struct {
	UserID      uuid.UUID `json:"user_id"`
	MinMsPlayed int32     `json:"min_ms_played"`
	StartDate   time.Time `json:"start_date"`
	EndDate     time.Time `json:"end_date"`
	ArtistUris  []string  `json:"artist_uris"`
	AlbumURI    *string   `json:"album_uri"`
	MaxTracks   int32     `json:"max_tracks"`
}

type HistoryGetTopTracksInTimeframeRow struct {
	SpotifyTrackUri string `json:"spotify_track_uri"`
	Occurrences     int64  `json:"occurrences"`
}

func (q *Queries) HistoryGetTopTracksInTimeframe(ctx context.Context, arg HistoryGetTopTracksInTimeframeParams) ([]*HistoryGetTopTracksInTimeframeRow, error) {
	rows, err := q.db.Query(ctx, historyGetTopTracksInTimeframe,
		arg.UserID,
		arg.MinMsPlayed,
		arg.StartDate,
		arg.EndDate,
		arg.ArtistUris,
		arg.AlbumURI,
		arg.MaxTracks,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*HistoryGetTopTracksInTimeframeRow
	for rows.Next() {
		var i HistoryGetTopTracksInTimeframeRow
		if err := rows.Scan(&i.SpotifyTrackUri, &i.Occurrences); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const historyGetTopTracksInTimeframeDedup = `-- name: HistoryGetTopTracksInTimeframeDedup :many
WITH top_isrcs AS (
    SELECT
        tc.isrc,
        COUNT(*) AS occurrences,
(json_agg(DISTINCT h.spotify_track_uri)) AS spotify_track_uris
    FROM
        spotify_history h
        JOIN spotify_track_cache tc ON tc.uri = h.spotify_track_uri
    WHERE
        user_id = $1
        AND ms_played >= $2
        AND timestamp BETWEEN $3::timestamp AND $4::timestamp
        AND ($5::text[] IS NULL
            OR spotify_artist_uri = ANY ($5::text[]))
        AND ($6::text IS NULL
            OR h.spotify_album_uri = $6::text)
    GROUP BY
        tc.isrc
    ORDER BY
        COUNT(*) DESC
    LIMIT $7
),
pref_albums AS (
    SELECT DISTINCT ON (top_isrcs.isrc)
        top_isrcs.isrc, top_isrcs.occurrences, top_isrcs.spotify_track_uris,
        tc.uri AS spotify_track_uri
    FROM
        top_isrcs
        JOIN spotify_track_cache tc ON tc.isrc = top_isrcs.isrc
        JOIN spotify_album_cache ac ON ac.id = tc.album_id
    ORDER BY
        top_isrcs.isrc,
        CASE WHEN ac.album_type = 'album' THEN
            1
        WHEN ac.album_type = 'single' THEN
            2
        WHEN ac.album_type = 'compilation' THEN
            3
        ELSE
            4
        END,
        release_date ASC
)
SELECT
    isrc, occurrences, spotify_track_uris, spotify_track_uri
FROM
    pref_albums
ORDER BY
    occurrences DESC
`

type HistoryGetTopTracksInTimeframeDedupParams struct {
	UserID      uuid.UUID `json:"user_id"`
	MinMsPlayed int32     `json:"min_ms_played"`
	StartDate   time.Time `json:"start_date"`
	EndDate     time.Time `json:"end_date"`
	ArtistUris  []string  `json:"artist_uris"`
	AlbumURI    *string   `json:"album_uri"`
	MaxTracks   int32     `json:"max_tracks"`
}

type HistoryGetTopTracksInTimeframeDedupRow struct {
	Isrc             *string `json:"isrc"`
	Occurrences      int64   `json:"occurrences"`
	SpotifyTrackUris []byte  `json:"spotify_track_uris"`
	SpotifyTrackUri  string  `json:"spotify_track_uri"`
}

func (q *Queries) HistoryGetTopTracksInTimeframeDedup(ctx context.Context, arg HistoryGetTopTracksInTimeframeDedupParams) ([]*HistoryGetTopTracksInTimeframeDedupRow, error) {
	rows, err := q.db.Query(ctx, historyGetTopTracksInTimeframeDedup,
		arg.UserID,
		arg.MinMsPlayed,
		arg.StartDate,
		arg.EndDate,
		arg.ArtistUris,
		arg.AlbumURI,
		arg.MaxTracks,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*HistoryGetTopTracksInTimeframeDedupRow
	for rows.Next() {
		var i HistoryGetTopTracksInTimeframeDedupRow
		if err := rows.Scan(
			&i.Isrc,
			&i.Occurrences,
			&i.SpotifyTrackUris,
			&i.SpotifyTrackUri,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const historyGetTopTracksNotInCache = `-- name: HistoryGetTopTracksNotInCache :many
SELECT
    SPOTIFY_TRACK_URI,
    COUNT(SPOTIFY_TRACK_URI)
FROM
    spotify_history h
    LEFT JOIN spotify_track_cache tc ON h.spotify_track_uri = tc.uri
WHERE
    tc.uri IS NULL
GROUP BY
    SPOTIFY_TRACK_URI
ORDER BY
    COUNT DESC
LIMIT 50
`

type HistoryGetTopTracksNotInCacheRow struct {
	SpotifyTrackUri string `json:"spotify_track_uri"`
	Count           int64  `json:"count"`
}

func (q *Queries) HistoryGetTopTracksNotInCache(ctx context.Context) ([]*HistoryGetTopTracksNotInCacheRow, error) {
	rows, err := q.db.Query(ctx, historyGetTopTracksNotInCache)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*HistoryGetTopTracksNotInCacheRow
	for rows.Next() {
		var i HistoryGetTopTracksNotInCacheRow
		if err := rows.Scan(&i.SpotifyTrackUri, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const historyGetTopTracksWithoutURIs = `-- name: HistoryGetTopTracksWithoutURIs :many
SELECT
    SPOTIFY_TRACK_URI,
    COUNT(SPOTIFY_TRACK_URI)
FROM
    spotify_history
WHERE
    spotify_artist_uri IS NULL
GROUP BY
    SPOTIFY_TRACK_URI
ORDER BY
    COUNT DESC
LIMIT 50
`

type HistoryGetTopTracksWithoutURIsRow struct {
	SpotifyTrackUri string `json:"spotify_track_uri"`
	Count           int64  `json:"count"`
}

func (q *Queries) HistoryGetTopTracksWithoutURIs(ctx context.Context) ([]*HistoryGetTopTracksWithoutURIsRow, error) {
	rows, err := q.db.Query(ctx, historyGetTopTracksWithoutURIs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*HistoryGetTopTracksWithoutURIsRow
	for rows.Next() {
		var i HistoryGetTopTracksWithoutURIsRow
		if err := rows.Scan(&i.SpotifyTrackUri, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const historyGetTrackStreamCountByYear = `-- name: HistoryGetTrackStreamCountByYear :many
SELECT
    track_name,
    COUNT(*) AS occurrences
FROM
    spotify_history
WHERE
    user_id = $1
    AND ms_played >= $2
    AND timestamp BETWEEN ($3::int || '-01-01 00:00:00')::timestamp AND (cast((($3::int) + 1) AS text) || '-01-01 00:00:00')::timestamp
GROUP BY
    track_name
ORDER BY
    COUNT(*) DESC
LIMIT 35
`

type HistoryGetTrackStreamCountByYearParams struct {
	UserID      uuid.UUID `json:"user_id"`
	MinMsPlayed int32     `json:"min_ms_played"`
	Year        int32     `json:"year"`
}

type HistoryGetTrackStreamCountByYearRow struct {
	TrackName   string `json:"track_name"`
	Occurrences int64  `json:"occurrences"`
}

func (q *Queries) HistoryGetTrackStreamCountByYear(ctx context.Context, arg HistoryGetTrackStreamCountByYearParams) ([]*HistoryGetTrackStreamCountByYearRow, error) {
	rows, err := q.db.Query(ctx, historyGetTrackStreamCountByYear, arg.UserID, arg.MinMsPlayed, arg.Year)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*HistoryGetTrackStreamCountByYearRow
	for rows.Next() {
		var i HistoryGetTrackStreamCountByYearRow
		if err := rows.Scan(&i.TrackName, &i.Occurrences); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const historyGetTrackURIForAlbum = `-- name: HistoryGetTrackURIForAlbum :one
SELECT
    spotify_track_uri
FROM
    spotify_history
WHERE
    artist_name = $1
    AND user_id = $2
LIMIT 1
`

type HistoryGetTrackURIForAlbumParams struct {
	ArtistName string    `json:"artist_name"`
	UserID     uuid.UUID `json:"user_id"`
}

func (q *Queries) HistoryGetTrackURIForAlbum(ctx context.Context, arg HistoryGetTrackURIForAlbumParams) (string, error) {
	row := q.db.QueryRow(ctx, historyGetTrackURIForAlbum, arg.ArtistName, arg.UserID)
	var spotify_track_uri string
	err := row.Scan(&spotify_track_uri)
	return spotify_track_uri, err
}

const historyInsertBulk = `-- name: HistoryInsertBulk :exec
INSERT INTO SPOTIFY_HISTORY(
    user_id,
    timestamp,
    platform,
    ms_played,
    conn_country,
    ip_addr,
    user_agent,
    track_name,
    artist_name,
    album_name,
    spotify_track_uri,
    spotify_artist_uri,
    spotify_album_uri,
    reason_start,
    reason_end,
    shuffle,
    skipped,
    offline,
    offline_timestamp,
    incognito_mode,
    from_history,
    isrc)
VALUES (
    unnest(
        $1::uuid[]),
    unnest(
        $2::timestamp[]),
    unnest(
        $3::text[]),
    unnest(
        $4::integer[]),
    unnest(
        $5::text[]),
    unnest(
        $6::text[]),
    unnest(
        $7::text[]),
    unnest(
        $8::text[]),
    unnest(
        $9::text[]),
    unnest(
        $10::text[]),
    unnest(
        $11::text[]),
    unnest(
        $12::text[]),
    unnest(
        $13::text[]),
    unnest(
        $14::text[]),
    unnest(
        $15::text[]),
    unnest(
        $16::boolean[]),
    unnest(
        $17::boolean[]),
    unnest(
        $18::boolean[]),
    unnest(
        $19::timestamp[]),
    unnest(
        $20::boolean[]),
    unnest(
        $21::boolean[]),
    unnest(
        $22::text[]))
ON CONFLICT
    DO NOTHING
`

type HistoryInsertBulkParams struct {
	UserIds          []uuid.UUID `json:"user_ids"`
	Timestamp        []time.Time `json:"timestamp"`
	Platform         []string    `json:"platform"`
	MsPlayed         []int32     `json:"ms_played"`
	ConnCountry      []string    `json:"conn_country"`
	IpAddr           []string    `json:"ip_addr"`
	UserAgent        []string    `json:"user_agent"`
	TrackName        []string    `json:"track_name"`
	ArtistName       []string    `json:"artist_name"`
	AlbumName        []string    `json:"album_name"`
	SpotifyTrackUri  []string    `json:"spotify_track_uri"`
	SpotifyArtistUri []string    `json:"spotify_artist_uri"`
	SpotifyAlbumUri  []string    `json:"spotify_album_uri"`
	ReasonStart      []string    `json:"reason_start"`
	ReasonEnd        []string    `json:"reason_end"`
	Shuffle          []bool      `json:"shuffle"`
	Skipped          []bool      `json:"skipped"`
	Offline          []bool      `json:"offline"`
	OfflineTimestamp []time.Time `json:"offline_timestamp"`
	IncognitoMode    []bool      `json:"incognito_mode"`
	FromHistory      []bool      `json:"from_history"`
	Isrc             []string    `json:"isrc"`
}

func (q *Queries) HistoryInsertBulk(ctx context.Context, arg HistoryInsertBulkParams) error {
	_, err := q.db.Exec(ctx, historyInsertBulk,
		arg.UserIds,
		arg.Timestamp,
		arg.Platform,
		arg.MsPlayed,
		arg.ConnCountry,
		arg.IpAddr,
		arg.UserAgent,
		arg.TrackName,
		arg.ArtistName,
		arg.AlbumName,
		arg.SpotifyTrackUri,
		arg.SpotifyArtistUri,
		arg.SpotifyAlbumUri,
		arg.ReasonStart,
		arg.ReasonEnd,
		arg.Shuffle,
		arg.Skipped,
		arg.Offline,
		arg.OfflineTimestamp,
		arg.IncognitoMode,
		arg.FromHistory,
		arg.Isrc,
	)
	return err
}

const historyInsertOne = `-- name: HistoryInsertOne :exec
INSERT INTO SPOTIFY_HISTORY(
    user_id,
    timestamp,
    platform,
    ms_played,
    conn_country,
    ip_addr,
    user_agent,
    track_name,
    artist_name,
    album_name,
    spotify_track_uri,
    spotify_artist_uri,
    spotify_album_uri,
    reason_start,
    reason_end,
    shuffle,
    skipped,
    offline,
    offline_timestamp,
    incognito_mode,
    from_history,
    isrc)
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12,
    $13,
    $14,
    $15,
    $16,
    $17,
    $18,
    $19,
    $20,
    $21,
    $22)
`

type HistoryInsertOneParams struct {
	UserID           uuid.UUID  `json:"user_id"`
	Timestamp        time.Time  `json:"timestamp"`
	Platform         string     `json:"platform"`
	MsPlayed         int32      `json:"ms_played"`
	ConnCountry      string     `json:"conn_country"`
	IpAddr           *string    `json:"ip_addr"`
	UserAgent        *string    `json:"user_agent"`
	TrackName        string     `json:"track_name"`
	ArtistName       string     `json:"artist_name"`
	AlbumName        string     `json:"album_name"`
	SpotifyTrackUri  string     `json:"spotify_track_uri"`
	SpotifyArtistUri *string    `json:"spotify_artist_uri"`
	SpotifyAlbumUri  *string    `json:"spotify_album_uri"`
	ReasonStart      *string    `json:"reason_start"`
	ReasonEnd        *string    `json:"reason_end"`
	Shuffle          bool       `json:"shuffle"`
	Skipped          *bool      `json:"skipped"`
	Offline          bool       `json:"offline"`
	OfflineTimestamp *time.Time `json:"offline_timestamp"`
	IncognitoMode    bool       `json:"incognito_mode"`
	FromHistory      bool       `json:"from_history"`
	Isrc             *string    `json:"isrc"`
}

func (q *Queries) HistoryInsertOne(ctx context.Context, arg HistoryInsertOneParams) error {
	_, err := q.db.Exec(ctx, historyInsertOne,
		arg.UserID,
		arg.Timestamp,
		arg.Platform,
		arg.MsPlayed,
		arg.ConnCountry,
		arg.IpAddr,
		arg.UserAgent,
		arg.TrackName,
		arg.ArtistName,
		arg.AlbumName,
		arg.SpotifyTrackUri,
		arg.SpotifyArtistUri,
		arg.SpotifyAlbumUri,
		arg.ReasonStart,
		arg.ReasonEnd,
		arg.Shuffle,
		arg.Skipped,
		arg.Offline,
		arg.OfflineTimestamp,
		arg.IncognitoMode,
		arg.FromHistory,
		arg.Isrc,
	)
	return err
}

const historySetURIsForTrack = `-- name: HistorySetURIsForTrack :exec
UPDATE
    spotify_history
SET
    spotify_artist_uri = $1,
    spotify_album_uri = $2
WHERE
    spotify_track_uri = $3
`

type HistorySetURIsForTrackParams struct {
	SpotifyArtistUri *string `json:"spotify_artist_uri"`
	SpotifyAlbumUri  *string `json:"spotify_album_uri"`
	SpotifyTrackUri  string  `json:"spotify_track_uri"`
}

func (q *Queries) HistorySetURIsForTrack(ctx context.Context, arg HistorySetURIsForTrackParams) error {
	_, err := q.db.Exec(ctx, historySetURIsForTrack, arg.SpotifyArtistUri, arg.SpotifyAlbumUri, arg.SpotifyTrackUri)
	return err
}

const missingArtistURIs = `-- name: MissingArtistURIs :many
SELECT
  SPOTIFY_TRACK_URI,
  COUNT(SPOTIFY_TRACK_URI),
(array_agg(track_name))[1] AS track_name,
(array_agg(artist_name))[1] AS artist_name,
(array_agg(DISTINCT user_id))::text[] AS user_ids
FROM
  spotify_history
WHERE
  spotify_artist_uri IS NULL
GROUP BY
  SPOTIFY_TRACK_URI
ORDER BY
  COUNT DESC
`

type MissingArtistURIsRow struct {
	SpotifyTrackUri string      `json:"spotify_track_uri"`
	Count           int64       `json:"count"`
	TrackName       interface{} `json:"track_name"`
	ArtistName      interface{} `json:"artist_name"`
	UserIds         []string    `json:"user_ids"`
}

func (q *Queries) MissingArtistURIs(ctx context.Context) ([]*MissingArtistURIsRow, error) {
	rows, err := q.db.Query(ctx, missingArtistURIs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*MissingArtistURIsRow
	for rows.Next() {
		var i MissingArtistURIsRow
		if err := rows.Scan(
			&i.SpotifyTrackUri,
			&i.Count,
			&i.TrackName,
			&i.ArtistName,
			&i.UserIds,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const missingISRCNumbers = `-- name: MissingISRCNumbers :many
SELECT
  h.user_id, h.timestamp, h.platform, h.ms_played, h.conn_country, h.ip_addr, h.user_agent, h.track_name, h.artist_name, h.album_name, h.spotify_track_uri, h.reason_start, h.reason_end, h.shuffle, h.skipped, h.offline, h.offline_timestamp, h.incognito_mode, h.spotify_artist_uri, h.spotify_album_uri, h.from_history, h.isrc,
  tc.isrc
FROM
  SPOTIFY_HISTORY h
  JOIN spotify_track_cache tc ON h.ISRC IS NULL
    AND tc.isrc IS NOT NULL
    AND tc.uri = h.spotify_track_uri
  ORDER BY
    TIMESTAMP DESC
`

type MissingISRCNumbersRow struct {
	UserID           uuid.UUID  `json:"user_id"`
	Timestamp        time.Time  `json:"timestamp"`
	Platform         string     `json:"platform"`
	MsPlayed         int32      `json:"ms_played"`
	ConnCountry      string     `json:"conn_country"`
	IpAddr           *string    `json:"ip_addr"`
	UserAgent        *string    `json:"user_agent"`
	TrackName        string     `json:"track_name"`
	ArtistName       string     `json:"artist_name"`
	AlbumName        string     `json:"album_name"`
	SpotifyTrackUri  string     `json:"spotify_track_uri"`
	ReasonStart      *string    `json:"reason_start"`
	ReasonEnd        *string    `json:"reason_end"`
	Shuffle          bool       `json:"shuffle"`
	Skipped          *bool      `json:"skipped"`
	Offline          bool       `json:"offline"`
	OfflineTimestamp *time.Time `json:"offline_timestamp"`
	IncognitoMode    bool       `json:"incognito_mode"`
	SpotifyArtistUri *string    `json:"spotify_artist_uri"`
	SpotifyAlbumUri  *string    `json:"spotify_album_uri"`
	FromHistory      bool       `json:"from_history"`
	Isrc             *string    `json:"isrc"`
	Isrc_2           *string    `json:"isrc_2"`
}

func (q *Queries) MissingISRCNumbers(ctx context.Context) ([]*MissingISRCNumbersRow, error) {
	rows, err := q.db.Query(ctx, missingISRCNumbers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*MissingISRCNumbersRow
	for rows.Next() {
		var i MissingISRCNumbersRow
		if err := rows.Scan(
			&i.UserID,
			&i.Timestamp,
			&i.Platform,
			&i.MsPlayed,
			&i.ConnCountry,
			&i.IpAddr,
			&i.UserAgent,
			&i.TrackName,
			&i.ArtistName,
			&i.AlbumName,
			&i.SpotifyTrackUri,
			&i.ReasonStart,
			&i.ReasonEnd,
			&i.Shuffle,
			&i.Skipped,
			&i.Offline,
			&i.OfflineTimestamp,
			&i.IncognitoMode,
			&i.SpotifyArtistUri,
			&i.SpotifyAlbumUri,
			&i.FromHistory,
			&i.Isrc,
			&i.Isrc_2,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const roomAddMember = `-- name: RoomAddMember :exec
INSERT INTO room_members(
    user_id,
    room_id)
VALUES (
    $1,
    $2)
`

type RoomAddMemberParams struct {
	UserID uuid.UUID `json:"user_id"`
	RoomID uuid.UUID `json:"room_id"`
}

func (q *Queries) RoomAddMember(ctx context.Context, arg RoomAddMemberParams) error {
	_, err := q.db.Exec(ctx, roomAddMember, arg.UserID, arg.RoomID)
	return err
}

const roomAddMemberByUsername = `-- name: RoomAddMemberByUsername :one
INSERT INTO room_members(
    user_id,
    room_id,
    is_moderator)
SELECT
    u.id,
    $1,
    $3
FROM
    users u
WHERE
    u.username = $2
RETURNING
    id
`

type RoomAddMemberByUsernameParams struct {
	RoomID      uuid.UUID `json:"room_id"`
	Username    string    `json:"username"`
	IsModerator bool      `json:"is_moderator"`
}

func (q *Queries) RoomAddMemberByUsername(ctx context.Context, arg RoomAddMemberByUsernameParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, roomAddMemberByUsername, arg.RoomID, arg.Username, arg.IsModerator)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const roomDeleteByID = `-- name: RoomDeleteByID :exec
DELETE FROM rooms r
WHERE r.code = $1
`

func (q *Queries) RoomDeleteByID(ctx context.Context, code string) error {
	_, err := q.db.Exec(ctx, roomDeleteByID, code)
	return err
}

const roomGetAllGuests = `-- name: RoomGetAllGuests :many
SELECT
    rg.name,
    rg.id,
    CASE WHEN counts.queued_tracks IS NOT NULL THEN
        counts.queued_tracks
    ELSE
        0
    END AS queued_tracks
FROM
    room_guests AS rg
    LEFT JOIN (
        SELECT
            guest_id,
            COUNT(*) AS queued_tracks
        FROM
            room_queue_tracks
        GROUP BY
            guest_id) counts ON rg.id = counts.guest_id
WHERE
    rg.room_id = $1
`

type RoomGetAllGuestsRow struct {
	Name         string    `json:"name"`
	ID           uuid.UUID `json:"id"`
	QueuedTracks int32     `json:"queued_tracks"`
}

func (q *Queries) RoomGetAllGuests(ctx context.Context, roomID uuid.UUID) ([]*RoomGetAllGuestsRow, error) {
	rows, err := q.db.Query(ctx, roomGetAllGuests, roomID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*RoomGetAllGuestsRow
	for rows.Next() {
		var i RoomGetAllGuestsRow
		if err := rows.Scan(&i.Name, &i.ID, &i.QueuedTracks); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const roomGetAllMembers = `-- name: RoomGetAllMembers :many
SELECT
    u.id AS user_id,
    u.username,
    u.display_name,
    u.spotify_name,
    u.spotify_image_url,
    m.is_moderator,
    CASE WHEN counts.queued_tracks IS NOT NULL THEN
        counts.queued_tracks
    ELSE
        0
    END AS queued_tracks
FROM
    room_members AS m
    JOIN users u ON m.user_id = u.id
        AND m.room_id = $1
    LEFT JOIN (
        SELECT
            user_id,
            COUNT(*) AS queued_tracks
        FROM
            room_queue_tracks
        GROUP BY
            user_id) counts ON u.id = counts.user_id
`

type RoomGetAllMembersRow struct {
	UserID          uuid.UUID `json:"user_id"`
	Username        string    `json:"username"`
	DisplayName     string    `json:"display_name"`
	SpotifyName     *string   `json:"spotify_name"`
	SpotifyImageUrl *string   `json:"spotify_image_url"`
	IsModerator     bool      `json:"is_moderator"`
	QueuedTracks    int32     `json:"queued_tracks"`
}

func (q *Queries) RoomGetAllMembers(ctx context.Context, roomID uuid.UUID) ([]*RoomGetAllMembersRow, error) {
	rows, err := q.db.Query(ctx, roomGetAllMembers, roomID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*RoomGetAllMembersRow
	for rows.Next() {
		var i RoomGetAllMembersRow
		if err := rows.Scan(
			&i.UserID,
			&i.Username,
			&i.DisplayName,
			&i.SpotifyName,
			&i.SpotifyImageUrl,
			&i.IsModerator,
			&i.QueuedTracks,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const roomGetByCode = `-- name: RoomGetByCode :one
SELECT
    r.id,
    r.name,
    r.host_id,
    u.username AS host_username,
    u.display_name AS host_display,
    u.spotify_name AS host_spotify_name,
    u.spotify_image_url AS host_image,
    r.code,
    r.created
FROM
    rooms AS r
    JOIN users AS u ON r.code = $1
        AND u.id = r.host_id
`

type RoomGetByCodeRow struct {
	ID              uuid.UUID `json:"id"`
	Name            string    `json:"name"`
	HostID          uuid.UUID `json:"host_id"`
	HostUsername    string    `json:"host_username"`
	HostDisplay     string    `json:"host_display"`
	HostSpotifyName *string   `json:"host_spotify_name"`
	HostImage       *string   `json:"host_image"`
	Code            string    `json:"code"`
	Created         time.Time `json:"created"`
}

func (q *Queries) RoomGetByCode(ctx context.Context, code string) (*RoomGetByCodeRow, error) {
	row := q.db.QueryRow(ctx, roomGetByCode, code)
	var i RoomGetByCodeRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.HostID,
		&i.HostUsername,
		&i.HostDisplay,
		&i.HostSpotifyName,
		&i.HostImage,
		&i.Code,
		&i.Created,
	)
	return &i, err
}

const roomGetHostID = `-- name: RoomGetHostID :one
SELECT
    r.host_id
FROM
    rooms r
WHERE
    r.code = $1
`

func (q *Queries) RoomGetHostID(ctx context.Context, code string) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, roomGetHostID, code)
	var host_id uuid.UUID
	err := row.Scan(&host_id)
	return host_id, err
}

const roomGetIDByCode = `-- name: RoomGetIDByCode :one
SELECT
    id
FROM
    rooms
WHERE (code = $1)
`

func (q *Queries) RoomGetIDByCode(ctx context.Context, code string) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, roomGetIDByCode, code)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const roomGetQueueTracks = `-- name: RoomGetQueueTracks :many
SELECT
    track_id,
    g.name AS guest_name,
    u.display_name AS member_name,
    timestamp,
    played
FROM
    room_queue_tracks t
    LEFT JOIN room_guests g ON g.id = t.guest_id
    LEFT JOIN users u ON u.id = t.user_id
WHERE
    t.room_id = $1
ORDER BY
    timestamp DESC
`

type RoomGetQueueTracksRow struct {
	TrackID    string    `json:"track_id"`
	GuestName  *string   `json:"guest_name"`
	MemberName *string   `json:"member_name"`
	Timestamp  time.Time `json:"timestamp"`
	Played     bool      `json:"played"`
}

func (q *Queries) RoomGetQueueTracks(ctx context.Context, roomID uuid.UUID) ([]*RoomGetQueueTracksRow, error) {
	rows, err := q.db.Query(ctx, roomGetQueueTracks, roomID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*RoomGetQueueTracksRow
	for rows.Next() {
		var i RoomGetQueueTracksRow
		if err := rows.Scan(
			&i.TrackID,
			&i.GuestName,
			&i.MemberName,
			&i.Timestamp,
			&i.Played,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const roomGuestGetName = `-- name: RoomGuestGetName :one
SELECT
    name
FROM
    room_guests
WHERE
    room_id = $1
    AND id = $2::uuid
`

type RoomGuestGetNameParams struct {
	RoomID  uuid.UUID `json:"room_id"`
	GuestID uuid.UUID `json:"guest_id"`
}

func (q *Queries) RoomGuestGetName(ctx context.Context, arg RoomGuestGetNameParams) (string, error) {
	row := q.db.QueryRow(ctx, roomGuestGetName, arg.RoomID, arg.GuestID)
	var name string
	err := row.Scan(&name)
	return name, err
}

const roomGuestInsert = `-- name: RoomGuestInsert :one
INSERT INTO room_guests(
    room_id,
    name)
SELECT
    r.id,
    $1
FROM
    rooms AS r
WHERE
    r.code = $2::text
RETURNING
    id,
    name
`

type RoomGuestInsertParams struct {
	Name     string `json:"name"`
	RoomCode string `json:"room_code"`
}

type RoomGuestInsertRow struct {
	ID   uuid.UUID `json:"id"`
	Name string    `json:"name"`
}

func (q *Queries) RoomGuestInsert(ctx context.Context, arg RoomGuestInsertParams) (*RoomGuestInsertRow, error) {
	row := q.db.QueryRow(ctx, roomGuestInsert, arg.Name, arg.RoomCode)
	var i RoomGuestInsertRow
	err := row.Scan(&i.ID, &i.Name)
	return &i, err
}

const roomGuestInsertWithID = `-- name: RoomGuestInsertWithID :one
INSERT INTO room_guests(
    id,
    room_id,
    name)
SELECT
    $2::uuid,
    r.id,
    $1
FROM
    rooms AS r
WHERE
    r.code = $3::text
RETURNING
    id,
    name
`

type RoomGuestInsertWithIDParams struct {
	Name     string    `json:"name"`
	GuestID  uuid.UUID `json:"guest_id"`
	RoomCode string    `json:"room_code"`
}

type RoomGuestInsertWithIDRow struct {
	ID   uuid.UUID `json:"id"`
	Name string    `json:"name"`
}

func (q *Queries) RoomGuestInsertWithID(ctx context.Context, arg RoomGuestInsertWithIDParams) (*RoomGuestInsertWithIDRow, error) {
	row := q.db.QueryRow(ctx, roomGuestInsertWithID, arg.Name, arg.GuestID, arg.RoomCode)
	var i RoomGuestInsertWithIDRow
	err := row.Scan(&i.ID, &i.Name)
	return &i, err
}

const roomInsertWithPassword = `-- name: RoomInsertWithPassword :one
WITH new_room AS (
    INSERT INTO rooms(
        name,
        host_id)
    VALUES (
        $1,
        $2)
RETURNING
    id,
    name,
    host_id,
    code,
    created
),
new_pass AS (
    INSERT INTO room_passwords(
        room_id,
        encrypted_password)
    SELECT
        id,
        crypt($3, gen_salt('bf'))
    FROM
        new_room
)
SELECT
    id, name, host_id, code, created
FROM
    new_room
`

type RoomInsertWithPasswordParams struct {
	Name     string    `json:"name"`
	HostID   uuid.UUID `json:"host_id"`
	RoomPass string    `json:"room_pass"`
}

type RoomInsertWithPasswordRow struct {
	ID      uuid.UUID `json:"id"`
	Name    string    `json:"name"`
	HostID  uuid.UUID `json:"host_id"`
	Code    string    `json:"code"`
	Created time.Time `json:"created"`
}

func (q *Queries) RoomInsertWithPassword(ctx context.Context, arg RoomInsertWithPasswordParams) (*RoomInsertWithPasswordRow, error) {
	row := q.db.QueryRow(ctx, roomInsertWithPassword, arg.Name, arg.HostID, arg.RoomPass)
	var i RoomInsertWithPasswordRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.HostID,
		&i.Code,
		&i.Created,
	)
	return &i, err
}

const roomMarkTracksAsPlayed = `-- name: RoomMarkTracksAsPlayed :exec
UPDATE
    room_queue_tracks
SET
    played = TRUE
WHERE
    room_id = $1
    AND timestamp <= $2
`

type RoomMarkTracksAsPlayedParams struct {
	RoomID    uuid.UUID `json:"room_id"`
	Timestamp time.Time `json:"timestamp"`
}

func (q *Queries) RoomMarkTracksAsPlayed(ctx context.Context, arg RoomMarkTracksAsPlayedParams) error {
	_, err := q.db.Exec(ctx, roomMarkTracksAsPlayed, arg.RoomID, arg.Timestamp)
	return err
}

const roomRemoveMember = `-- name: RoomRemoveMember :exec
DELETE FROM room_members rm
WHERE rm.room_id = $1
    AND rm.user_id = $2
`

type RoomRemoveMemberParams struct {
	RoomID uuid.UUID `json:"room_id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) RoomRemoveMember(ctx context.Context, arg RoomRemoveMemberParams) error {
	_, err := q.db.Exec(ctx, roomRemoveMember, arg.RoomID, arg.UserID)
	return err
}

const roomSetGuestQueueTrack = `-- name: RoomSetGuestQueueTrack :exec
INSERT INTO room_queue_tracks(
    track_id,
    guest_id,
    room_id)
SELECT
    $1,
    $2::uuid,
    r.id
FROM
    rooms AS r
WHERE
    r.code = $3::text
`

type RoomSetGuestQueueTrackParams struct {
	TrackID  string    `json:"track_id"`
	GuestID  uuid.UUID `json:"guest_id"`
	RoomCode string    `json:"room_code"`
}

func (q *Queries) RoomSetGuestQueueTrack(ctx context.Context, arg RoomSetGuestQueueTrackParams) error {
	_, err := q.db.Exec(ctx, roomSetGuestQueueTrack, arg.TrackID, arg.GuestID, arg.RoomCode)
	return err
}

const roomSetIsOpen = `-- name: RoomSetIsOpen :exec
UPDATE
    rooms
SET
    is_open = $2
WHERE
    id = $1
`

type RoomSetIsOpenParams struct {
	ID     uuid.UUID `json:"id"`
	IsOpen bool      `json:"is_open"`
}

func (q *Queries) RoomSetIsOpen(ctx context.Context, arg RoomSetIsOpenParams) error {
	_, err := q.db.Exec(ctx, roomSetIsOpen, arg.ID, arg.IsOpen)
	return err
}

const roomSetMemberQueueTrack = `-- name: RoomSetMemberQueueTrack :exec
INSERT INTO room_queue_tracks(
    track_id,
    user_id,
    room_id)
SELECT
    $1,
    $2::uuid,
    r.id
FROM
    rooms AS r
WHERE
    r.code = $3::text
`

type RoomSetMemberQueueTrackParams struct {
	TrackID  string    `json:"track_id"`
	UserID   uuid.UUID `json:"user_id"`
	RoomCode string    `json:"room_code"`
}

func (q *Queries) RoomSetMemberQueueTrack(ctx context.Context, arg RoomSetMemberQueueTrackParams) error {
	_, err := q.db.Exec(ctx, roomSetMemberQueueTrack, arg.TrackID, arg.UserID, arg.RoomCode)
	return err
}

const roomSetModerator = `-- name: RoomSetModerator :exec
UPDATE
    room_members
SET
    is_moderator = $3
WHERE
    room_id = $1
    AND user_id = $2
`

type RoomSetModeratorParams struct {
	RoomID      uuid.UUID `json:"room_id"`
	UserID      uuid.UUID `json:"user_id"`
	IsModerator bool      `json:"is_moderator"`
}

func (q *Queries) RoomSetModerator(ctx context.Context, arg RoomSetModeratorParams) error {
	_, err := q.db.Exec(ctx, roomSetModerator, arg.RoomID, arg.UserID, arg.IsModerator)
	return err
}

const roomUpdatePassword = `-- name: RoomUpdatePassword :exec
UPDATE
    room_passwords
SET
    encrypted_password = crypt($2, gen_salt('bf'))
WHERE
    room_id = $1
`

type RoomUpdatePasswordParams struct {
	RoomID   uuid.UUID `json:"room_id"`
	RoomPass string    `json:"room_pass"`
}

func (q *Queries) RoomUpdatePassword(ctx context.Context, arg RoomUpdatePasswordParams) error {
	_, err := q.db.Exec(ctx, roomUpdatePassword, arg.RoomID, arg.RoomPass)
	return err
}

const roomUpdateSpotifyTokens = `-- name: RoomUpdateSpotifyTokens :exec
UPDATE
    spotify_tokens st
SET
    encrypted_access_token = $2,
    access_token_expiry = $3,
    encrypted_refresh_token = $4
FROM
    rooms AS r
WHERE
    st.user_id = r.host_id
    AND r.code = $1
`

type RoomUpdateSpotifyTokensParams struct {
	Code                  string    `json:"code"`
	EncryptedAccessToken  []byte    `json:"encrypted_access_token"`
	AccessTokenExpiry     time.Time `json:"access_token_expiry"`
	EncryptedRefreshToken []byte    `json:"encrypted_refresh_token"`
}

func (q *Queries) RoomUpdateSpotifyTokens(ctx context.Context, arg RoomUpdateSpotifyTokensParams) error {
	_, err := q.db.Exec(ctx, roomUpdateSpotifyTokens,
		arg.Code,
		arg.EncryptedAccessToken,
		arg.AccessTokenExpiry,
		arg.EncryptedRefreshToken,
	)
	return err
}

const roomUserIsMember = `-- name: RoomUserIsMember :one
SELECT
    is_moderator
FROM
    room_members
WHERE
    user_id = $1
    AND room_id = $2
`

type RoomUserIsMemberParams struct {
	UserID uuid.UUID `json:"user_id"`
	RoomID uuid.UUID `json:"room_id"`
}

func (q *Queries) RoomUserIsMember(ctx context.Context, arg RoomUserIsMemberParams) (bool, error) {
	row := q.db.QueryRow(ctx, roomUserIsMember, arg.UserID, arg.RoomID)
	var is_moderator bool
	err := row.Scan(&is_moderator)
	return is_moderator, err
}

const roomValidatePassword = `-- name: RoomValidatePassword :one
SELECT
    (encrypted_password = crypt($2::text, encrypted_password::text))
FROM
    room_passwords AS rp
    JOIN rooms r ON r.id = rp.room_id
        AND r.code = $1
`

type RoomValidatePasswordParams struct {
	Code     string `json:"code"`
	RoomPass string `json:"room_pass"`
}

func (q *Queries) RoomValidatePassword(ctx context.Context, arg RoomValidatePasswordParams) (bool, error) {
	row := q.db.QueryRow(ctx, roomValidatePassword, arg.Code, arg.RoomPass)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const tableSizesAndRows = `-- name: TableSizesAndRows :many
SELECT
  nspname AS schema,
  relname AS table,
  reltuples AS rows_estimate,
  pg_relation_size(c.oid) AS rel_size_bytes,
  pg_indexes_size(c.oid) AS index_size_bytes,
  pg_total_relation_size(c.oid) AS total_size_bytes
FROM
  pg_catalog.pg_class c
  JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
WHERE
  relkind = 'r'
  AND nspname = 'public'
ORDER BY
  total_size_bytes DESC
`

type TableSizesAndRowsRow struct {
	Schema         string  `json:"schema"`
	Table          string  `json:"table"`
	RowsEstimate   float32 `json:"rows_estimate"`
	RelSizeBytes   int64   `json:"rel_size_bytes"`
	IndexSizeBytes int64   `json:"index_size_bytes"`
	TotalSizeBytes int64   `json:"total_size_bytes"`
}

func (q *Queries) TableSizesAndRows(ctx context.Context) ([]*TableSizesAndRowsRow, error) {
	rows, err := q.db.Query(ctx, tableSizesAndRows)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*TableSizesAndRowsRow
	for rows.Next() {
		var i TableSizesAndRowsRow
		if err := rows.Scan(
			&i.Schema,
			&i.Table,
			&i.RowsEstimate,
			&i.RelSizeBytes,
			&i.IndexSizeBytes,
			&i.TotalSizeBytes,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const trackCacheGetByID = `-- name: TrackCacheGetByID :many
SELECT
    id, uri, name, album_id, album_uri, album_name, artist_id, artist_uri, artist_name, image_url, other_artists, duration_ms, popularity, explicit, preview_url, disc_number, track_number, type, external_ids, isrc
FROM
    SPOTIFY_TRACK_CACHE
WHERE
    id = ANY ($1::text[])
`

func (q *Queries) TrackCacheGetByID(ctx context.Context, trackIds []string) ([]*TrackData, error) {
	rows, err := q.db.Query(ctx, trackCacheGetByID, trackIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*TrackData
	for rows.Next() {
		var i TrackData
		if err := rows.Scan(
			&i.ID,
			&i.URI,
			&i.Name,
			&i.AlbumID,
			&i.AlbumURI,
			&i.AlbumName,
			&i.ArtistID,
			&i.ArtistURI,
			&i.ArtistName,
			&i.ImageUrl,
			&i.OtherArtists,
			&i.DurationMs,
			&i.Popularity,
			&i.Explicit,
			&i.PreviewUrl,
			&i.DiscNumber,
			&i.TrackNumber,
			&i.Type,
			&i.ExternalIds,
			&i.Isrc,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const trackCacheInsertBulk = `-- name: TrackCacheInsertBulk :exec
INSERT INTO SPOTIFY_TRACK_CACHE(
    id,
    uri,
    name,
    album_id,
    album_uri,
    album_name,
    artist_id,
    artist_uri,
    artist_name,
    image_url,
    other_artists,
    duration_ms,
    popularity,
    explicit,
    preview_url,
    disc_number,
    track_number,
    type,
    external_ids,
    isrc)
VALUES (
    unnest(
        $1 ::text[]),
    unnest(
        $2 ::text[]),
    unnest(
        $3 ::text[]),
    unnest(
        $4 ::text[]),
    unnest(
        $5 ::text[]),
    unnest(
        $6 ::text[]),
    unnest(
        $7 ::text[]),
    unnest(
        $8 ::text[]),
    unnest(
        $9 ::text[]),
    unnest(
        $10 ::text[]),
    unnest(
        $11 ::jsonb[]),
    unnest(
        $12 ::int[]),
    unnest(
        $13 ::int[]),
    unnest(
        $14 ::bool[]),
    unnest(
        $15 ::text[]),
    unnest(
        $16 ::int[]),
    unnest(
        $17 ::int[]),
    unnest(
        $18 ::text[]),
    unnest(
        $19 ::jsonb[]),
    unnest(
        $20 ::text[]))
ON CONFLICT
    DO NOTHING
`

type TrackCacheInsertBulkParams struct {
	ID           []string `json:"id"`
	URI          []string `json:"uri"`
	Name         []string `json:"name"`
	AlbumID      []string `json:"album_id"`
	AlbumURI     []string `json:"album_uri"`
	AlbumName    []string `json:"album_name"`
	ArtistID     []string `json:"artist_id"`
	ArtistURI    []string `json:"artist_uri"`
	ArtistName   []string `json:"artist_name"`
	ImageUrl     []string `json:"image_url"`
	OtherArtists [][]byte `json:"other_artists"`
	DurationMs   []int32  `json:"duration_ms"`
	Popularity   []int32  `json:"popularity"`
	Explicit     []bool   `json:"explicit"`
	PreviewUrl   []string `json:"preview_url"`
	DiscNumber   []int32  `json:"disc_number"`
	TrackNumber  []int32  `json:"track_number"`
	Type         []string `json:"type"`
	ExternalIds  [][]byte `json:"external_ids"`
	Isrc         []string `json:"isrc"`
}

func (q *Queries) TrackCacheInsertBulk(ctx context.Context, arg TrackCacheInsertBulkParams) error {
	_, err := q.db.Exec(ctx, trackCacheInsertBulk,
		arg.ID,
		arg.URI,
		arg.Name,
		arg.AlbumID,
		arg.AlbumURI,
		arg.AlbumName,
		arg.ArtistID,
		arg.ArtistURI,
		arg.ArtistName,
		arg.ImageUrl,
		arg.OtherArtists,
		arg.DurationMs,
		arg.Popularity,
		arg.Explicit,
		arg.PreviewUrl,
		arg.DiscNumber,
		arg.TrackNumber,
		arg.Type,
		arg.ExternalIds,
		arg.Isrc,
	)
	return err
}

const tracksGetPrimaryURIs = `-- name: TracksGetPrimaryURIs :many
WITH top_isrcs AS (
    SELECT
        tc.isrc,
(json_agg(DISTINCT tc.uri)) AS original_uris
    FROM
        spotify_track_cache tc
    WHERE
        tc.uri = ANY ($1::text[])
    GROUP BY
        tc.isrc
),
pref_albums AS (
    SELECT DISTINCT ON (top_isrcs.isrc)
        top_isrcs.isrc, top_isrcs.original_uris,
        tc.uri AS primary_uri
    FROM
        top_isrcs
        JOIN spotify_track_cache tc ON tc.isrc = top_isrcs.isrc
        JOIN spotify_album_cache ac ON ac.id = tc.album_id
    ORDER BY
        top_isrcs.isrc,
        CASE WHEN ac.album_type = 'album' THEN
            1
        WHEN ac.album_type = 'single' THEN
            2
        WHEN ac.album_type = 'compilation' THEN
            3
        ELSE
            4
        END,
        release_date DESC
)
SELECT
    isrc, original_uris, primary_uri
FROM
    pref_albums
`

type TracksGetPrimaryURIsRow struct {
	Isrc         *string `json:"isrc"`
	OriginalUris []byte  `json:"original_uris"`
	PrimaryUri   string  `json:"primary_uri"`
}

func (q *Queries) TracksGetPrimaryURIs(ctx context.Context, uris []string) ([]*TracksGetPrimaryURIsRow, error) {
	rows, err := q.db.Query(ctx, tracksGetPrimaryURIs, uris)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*TracksGetPrimaryURIsRow
	for rows.Next() {
		var i TracksGetPrimaryURIsRow
		if err := rows.Scan(&i.Isrc, &i.OriginalUris, &i.PrimaryUri); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const uncachedTracks = `-- name: UncachedTracks :many
SELECT
  SPOTIFY_TRACK_URI,
  COUNT(SPOTIFY_TRACK_URI),
  TRACK_NAME,
  h.artist_name
FROM
  spotify_history h
  LEFT JOIN spotify_track_cache tc ON h.spotify_track_uri = tc.uri
WHERE
  tc.uri IS NULL
GROUP BY
  SPOTIFY_TRACK_URI,
  TRACK_NAME,
  h.ARTIST_NAME
ORDER BY
  COUNT DESC
`

type UncachedTracksRow struct {
	SpotifyTrackUri string `json:"spotify_track_uri"`
	Count           int64  `json:"count"`
	TrackName       string `json:"track_name"`
	ArtistName      string `json:"artist_name"`
}

func (q *Queries) UncachedTracks(ctx context.Context) ([]*UncachedTracksRow, error) {
	rows, err := q.db.Query(ctx, uncachedTracks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*UncachedTracksRow
	for rows.Next() {
		var i UncachedTracksRow
		if err := rows.Scan(
			&i.SpotifyTrackUri,
			&i.Count,
			&i.TrackName,
			&i.ArtistName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const userDeleteFriendRequest = `-- name: UserDeleteFriendRequest :exec
DELETE FROM user_friend_requests
WHERE user_id = $1
  AND friend_id = $2
`

type UserDeleteFriendRequestParams struct {
	UserID   uuid.UUID `json:"user_id"`
	FriendID uuid.UUID `json:"friend_id"`
}

func (q *Queries) UserDeleteFriendRequest(ctx context.Context, arg UserDeleteFriendRequestParams) error {
	_, err := q.db.Exec(ctx, userDeleteFriendRequest, arg.UserID, arg.FriendID)
	return err
}

const userDeleteSpotifyInfo = `-- name: UserDeleteSpotifyInfo :exec
UPDATE
  users
SET
  spotify_account = NULL,
  spotify_name = NULL,
  spotify_image_url = NULL
WHERE
  id = $1
`

func (q *Queries) UserDeleteSpotifyInfo(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, userDeleteSpotifyInfo, id)
	return err
}

const userDeleteSpotifyToken = `-- name: UserDeleteSpotifyToken :exec
DELETE FROM spotify_tokens
WHERE user_id = $1
`

func (q *Queries) UserDeleteSpotifyToken(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, userDeleteSpotifyToken, userID)
	return err
}

const userGetAllWithSpotify = `-- name: UserGetAllWithSpotify :many
SELECT
  id, username, display_name, spotify_account, spotify_name, spotify_image_url, created
FROM
  users
WHERE
  spotify_account IS NOT NULL
`

func (q *Queries) UserGetAllWithSpotify(ctx context.Context) ([]*User, error) {
	rows, err := q.db.Query(ctx, userGetAllWithSpotify)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.DisplayName,
			&i.SpotifyAccount,
			&i.SpotifyName,
			&i.SpotifyImageUrl,
			&i.Created,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const userGetByID = `-- name: UserGetByID :one
SELECT
  id,
  username,
  display_name,
  spotify_account,
  spotify_name,
  spotify_image_url
FROM
  users u
WHERE
  id = $1
`

type UserGetByIDRow struct {
	ID              uuid.UUID `json:"id"`
	Username        string    `json:"username"`
	DisplayName     string    `json:"display_name"`
	SpotifyAccount  *string   `json:"spotify_account"`
	SpotifyName     *string   `json:"spotify_name"`
	SpotifyImageUrl *string   `json:"spotify_image_url"`
}

func (q *Queries) UserGetByID(ctx context.Context, id uuid.UUID) (*UserGetByIDRow, error) {
	row := q.db.QueryRow(ctx, userGetByID, id)
	var i UserGetByIDRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.DisplayName,
		&i.SpotifyAccount,
		&i.SpotifyName,
		&i.SpotifyImageUrl,
	)
	return &i, err
}

const userGetByUsername = `-- name: UserGetByUsername :one
SELECT
  id,
  username,
  display_name,
  spotify_account,
  spotify_name,
  spotify_image_url
FROM
  users u
WHERE
  username = $1
`

type UserGetByUsernameRow struct {
	ID              uuid.UUID `json:"id"`
	Username        string    `json:"username"`
	DisplayName     string    `json:"display_name"`
	SpotifyAccount  *string   `json:"spotify_account"`
	SpotifyName     *string   `json:"spotify_name"`
	SpotifyImageUrl *string   `json:"spotify_image_url"`
}

func (q *Queries) UserGetByUsername(ctx context.Context, username string) (*UserGetByUsernameRow, error) {
	row := q.db.QueryRow(ctx, userGetByUsername, username)
	var i UserGetByUsernameRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.DisplayName,
		&i.SpotifyAccount,
		&i.SpotifyName,
		&i.SpotifyImageUrl,
	)
	return &i, err
}

const userGetFriendRequestExists = `-- name: UserGetFriendRequestExists :one
SELECT
  EXISTS (
    SELECT
      user_id, friend_id, request_timestamp
    FROM
      user_friend_requests
    WHERE
      user_id = $1
      AND friend_id = $2)
`

type UserGetFriendRequestExistsParams struct {
	UserID   uuid.UUID `json:"user_id"`
	FriendID uuid.UUID `json:"friend_id"`
}

func (q *Queries) UserGetFriendRequestExists(ctx context.Context, arg UserGetFriendRequestExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, userGetFriendRequestExists, arg.UserID, arg.FriendID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const userGetFriendSuggestions = `-- name: UserGetFriendSuggestions :many
SELECT
  id,
  username,
  display_name,
  spotify_image_url
FROM
  users u
WHERE
  NOT EXISTS (
    SELECT
      user_id, friend_id, request_timestamp
    FROM
      user_friend_requests fr
    WHERE
      fr.user_id = $1
      AND fr.friend_id = u.id)
  AND NOT EXISTS (
    SELECT
      user_id, friend_id, request_timestamp
    FROM
      user_friend_requests fr
    WHERE
      fr.friend_id = $1
      AND fr.user_id = u.id)
  AND NOT EXISTS (
    SELECT
      user_id, friend_id, added_timestamp
    FROM
      user_friends f
    WHERE
      f.user_id = $1
      AND f.friend_id = u.id)
  AND u.id != $1
`

type UserGetFriendSuggestionsRow struct {
	ID              uuid.UUID `json:"id"`
	Username        string    `json:"username"`
	DisplayName     string    `json:"display_name"`
	SpotifyImageUrl *string   `json:"spotify_image_url"`
}

func (q *Queries) UserGetFriendSuggestions(ctx context.Context, userID uuid.UUID) ([]*UserGetFriendSuggestionsRow, error) {
	rows, err := q.db.Query(ctx, userGetFriendSuggestions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*UserGetFriendSuggestionsRow
	for rows.Next() {
		var i UserGetFriendSuggestionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.DisplayName,
			&i.SpotifyImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const userGetFriends = `-- name: UserGetFriends :many
SELECT
  u.id, u.username, u.display_name, u.spotify_account, u.spotify_name, u.spotify_image_url, u.created
FROM
  user_friends f
  JOIN users u ON u.id = f.friend_id
    AND f.user_id = $1
`

func (q *Queries) UserGetFriends(ctx context.Context, userID uuid.UUID) ([]*User, error) {
	rows, err := q.db.Query(ctx, userGetFriends, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.DisplayName,
			&i.SpotifyAccount,
			&i.SpotifyName,
			&i.SpotifyImageUrl,
			&i.Created,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const userGetHostedRooms = `-- name: UserGetHostedRooms :many
SELECT
  r.id,
  r.name,
  r.code,
  r.created,
  u.id AS host_id,
  u.username AS host_username,
  u.display_name AS host_display_name,
  u.spotify_image_url AS host_spotify_image_url
FROM
  rooms r
  JOIN users u ON r.host_id = u.id
    AND u.id = $1
    AND r.is_open = $2
`

type UserGetHostedRoomsParams struct {
	ID     uuid.UUID `json:"id"`
	IsOpen bool      `json:"is_open"`
}

type UserGetHostedRoomsRow struct {
	ID                  uuid.UUID `json:"id"`
	Name                string    `json:"name"`
	Code                string    `json:"code"`
	Created             time.Time `json:"created"`
	HostID              uuid.UUID `json:"host_id"`
	HostUsername        string    `json:"host_username"`
	HostDisplayName     string    `json:"host_display_name"`
	HostSpotifyImageUrl *string   `json:"host_spotify_image_url"`
}

func (q *Queries) UserGetHostedRooms(ctx context.Context, arg UserGetHostedRoomsParams) ([]*UserGetHostedRoomsRow, error) {
	rows, err := q.db.Query(ctx, userGetHostedRooms, arg.ID, arg.IsOpen)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*UserGetHostedRoomsRow
	for rows.Next() {
		var i UserGetHostedRoomsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Code,
			&i.Created,
			&i.HostID,
			&i.HostUsername,
			&i.HostDisplayName,
			&i.HostSpotifyImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const userGetJoinedRooms = `-- name: UserGetJoinedRooms :many
SELECT
  r.id,
  r.name,
  r.code,
  r.created,
  u.id AS host_id,
  u.username AS host_username,
  u.display_name AS host_display_name,
  u.spotify_image_url AS host_spotify_image_url
FROM
  rooms r
  JOIN room_members rm ON rm.user_id = $1
    AND r.id = rm.room_id
    AND r.is_open = $2
  JOIN users u ON r.host_id = u.id
`

type UserGetJoinedRoomsParams struct {
	UserID uuid.UUID `json:"user_id"`
	IsOpen bool      `json:"is_open"`
}

type UserGetJoinedRoomsRow struct {
	ID                  uuid.UUID `json:"id"`
	Name                string    `json:"name"`
	Code                string    `json:"code"`
	Created             time.Time `json:"created"`
	HostID              uuid.UUID `json:"host_id"`
	HostUsername        string    `json:"host_username"`
	HostDisplayName     string    `json:"host_display_name"`
	HostSpotifyImageUrl *string   `json:"host_spotify_image_url"`
}

func (q *Queries) UserGetJoinedRooms(ctx context.Context, arg UserGetJoinedRoomsParams) ([]*UserGetJoinedRoomsRow, error) {
	rows, err := q.db.Query(ctx, userGetJoinedRooms, arg.UserID, arg.IsOpen)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*UserGetJoinedRoomsRow
	for rows.Next() {
		var i UserGetJoinedRoomsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Code,
			&i.Created,
			&i.HostID,
			&i.HostUsername,
			&i.HostDisplayName,
			&i.HostSpotifyImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const userGetReceivedFriendRequests = `-- name: UserGetReceivedFriendRequests :many
SELECT
  id,
  username,
  display_name,
  spotify_image_url,
  request_timestamp
FROM
  user_friend_requests fr
  JOIN users u ON fr.user_id = u.id
    AND $1 = fr.friend_id
`

type UserGetReceivedFriendRequestsRow struct {
	ID               uuid.UUID `json:"id"`
	Username         string    `json:"username"`
	DisplayName      string    `json:"display_name"`
	SpotifyImageUrl  *string   `json:"spotify_image_url"`
	RequestTimestamp time.Time `json:"request_timestamp"`
}

func (q *Queries) UserGetReceivedFriendRequests(ctx context.Context, userID uuid.UUID) ([]*UserGetReceivedFriendRequestsRow, error) {
	rows, err := q.db.Query(ctx, userGetReceivedFriendRequests, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*UserGetReceivedFriendRequestsRow
	for rows.Next() {
		var i UserGetReceivedFriendRequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.DisplayName,
			&i.SpotifyImageUrl,
			&i.RequestTimestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const userGetSentFriendRequests = `-- name: UserGetSentFriendRequests :many
SELECT
  id,
  username,
  display_name,
  spotify_image_url,
  request_timestamp
FROM
  user_friend_requests fr
  JOIN users u ON fr.friend_id = u.id
    AND $1 = fr.user_id
`

type UserGetSentFriendRequestsRow struct {
	ID               uuid.UUID `json:"id"`
	Username         string    `json:"username"`
	DisplayName      string    `json:"display_name"`
	SpotifyImageUrl  *string   `json:"spotify_image_url"`
	RequestTimestamp time.Time `json:"request_timestamp"`
}

func (q *Queries) UserGetSentFriendRequests(ctx context.Context, userID uuid.UUID) ([]*UserGetSentFriendRequestsRow, error) {
	rows, err := q.db.Query(ctx, userGetSentFriendRequests, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*UserGetSentFriendRequestsRow
	for rows.Next() {
		var i UserGetSentFriendRequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.DisplayName,
			&i.SpotifyImageUrl,
			&i.RequestTimestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const userGetSpotifyTokens = `-- name: UserGetSpotifyTokens :one
SELECT
  st.encrypted_access_token,
  st.access_token_expiry,
  st.encrypted_refresh_token
FROM
  spotify_tokens AS st
WHERE
  st.user_id = $1
`

type UserGetSpotifyTokensRow struct {
	EncryptedAccessToken  []byte    `json:"encrypted_access_token"`
	AccessTokenExpiry     time.Time `json:"access_token_expiry"`
	EncryptedRefreshToken []byte    `json:"encrypted_refresh_token"`
}

func (q *Queries) UserGetSpotifyTokens(ctx context.Context, userID uuid.UUID) (*UserGetSpotifyTokensRow, error) {
	row := q.db.QueryRow(ctx, userGetSpotifyTokens, userID)
	var i UserGetSpotifyTokensRow
	err := row.Scan(&i.EncryptedAccessToken, &i.AccessTokenExpiry, &i.EncryptedRefreshToken)
	return &i, err
}

const userHasSpotifyHistory = `-- name: UserHasSpotifyHistory :one
SELECT
  EXISTS (
    SELECT
      user_id, timestamp, platform, ms_played, conn_country, ip_addr, user_agent, track_name, artist_name, album_name, spotify_track_uri, reason_start, reason_end, shuffle, skipped, offline, offline_timestamp, incognito_mode, spotify_artist_uri, spotify_album_uri, from_history, isrc
    FROM
      SPOTIFY_HISTORY
    WHERE
      USER_ID = $1
      AND from_history = TRUE)
`

func (q *Queries) UserHasSpotifyHistory(ctx context.Context, userID uuid.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, userHasSpotifyHistory, userID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const userInsertFriend = `-- name: UserInsertFriend :exec
INSERT INTO user_friends(
  user_id,
  friend_id)
VALUES (
  $1,
  $2)
`

type UserInsertFriendParams struct {
	UserID   uuid.UUID `json:"user_id"`
	FriendID uuid.UUID `json:"friend_id"`
}

func (q *Queries) UserInsertFriend(ctx context.Context, arg UserInsertFriendParams) error {
	_, err := q.db.Exec(ctx, userInsertFriend, arg.UserID, arg.FriendID)
	return err
}

const userInsertWithPassword = `-- name: UserInsertWithPassword :one
WITH new_user AS (
  INSERT INTO users(
    username,
    display_name)
  VALUES (
    $1,
    $2)
RETURNING
  id,
  username,
  display_name,
  created)
INSERT INTO user_passwords(
  user_id,
  encrypted_password)
SELECT
  id,
  crypt($3, gen_salt('bf'))
FROM
  new_user
RETURNING (
  SELECT
    id
  FROM
    new_user)
`

type UserInsertWithPasswordParams struct {
	Username    string `json:"username"`
	DisplayName string `json:"display_name"`
	UserPass    string `json:"user_pass"`
}

func (q *Queries) UserInsertWithPassword(ctx context.Context, arg UserInsertWithPasswordParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, userInsertWithPassword, arg.Username, arg.DisplayName, arg.UserPass)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const userIsFriends = `-- name: UserIsFriends :one
SELECT
  EXISTS (
    SELECT
      user_id, friend_id, added_timestamp
    FROM
      user_friends
    WHERE
      user_id = $1
      AND friend_id = $2)
`

type UserIsFriendsParams struct {
	UserID   uuid.UUID `json:"user_id"`
	FriendID uuid.UUID `json:"friend_id"`
}

func (q *Queries) UserIsFriends(ctx context.Context, arg UserIsFriendsParams) (bool, error) {
	row := q.db.QueryRow(ctx, userIsFriends, arg.UserID, arg.FriendID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const userSendFriendRequest = `-- name: UserSendFriendRequest :exec
INSERT INTO user_friend_requests(
  user_id,
  friend_id)
VALUES (
  $1,
  $2)
`

type UserSendFriendRequestParams struct {
	UserID   uuid.UUID `json:"user_id"`
	FriendID uuid.UUID `json:"friend_id"`
}

func (q *Queries) UserSendFriendRequest(ctx context.Context, arg UserSendFriendRequestParams) error {
	_, err := q.db.Exec(ctx, userSendFriendRequest, arg.UserID, arg.FriendID)
	return err
}

const userUpdatePassword = `-- name: UserUpdatePassword :exec
UPDATE
  users
SET
  encrypted_password = crypt($1, gen_salt('bf'))
WHERE
  id = $2
`

type UserUpdatePasswordParams struct {
	UserPass string    `json:"user_pass"`
	UserID   uuid.UUID `json:"user_id"`
}

func (q *Queries) UserUpdatePassword(ctx context.Context, arg UserUpdatePasswordParams) error {
	_, err := q.db.Exec(ctx, userUpdatePassword, arg.UserPass, arg.UserID)
	return err
}

const userUpdateSpotifyInfo = `-- name: UserUpdateSpotifyInfo :exec
UPDATE
  users
SET
  spotify_account = $2,
  spotify_name = $3,
  spotify_image_url = $4
WHERE
  id = $1
`

type UserUpdateSpotifyInfoParams struct {
	ID              uuid.UUID `json:"id"`
	SpotifyAccount  *string   `json:"spotify_account"`
	SpotifyName     *string   `json:"spotify_name"`
	SpotifyImageUrl *string   `json:"spotify_image_url"`
}

func (q *Queries) UserUpdateSpotifyInfo(ctx context.Context, arg UserUpdateSpotifyInfoParams) error {
	_, err := q.db.Exec(ctx, userUpdateSpotifyInfo,
		arg.ID,
		arg.SpotifyAccount,
		arg.SpotifyName,
		arg.SpotifyImageUrl,
	)
	return err
}

const userUpdateSpotifyTokens = `-- name: UserUpdateSpotifyTokens :exec
WITH latest_perm_version AS (
  SELECT
    id
  FROM
    spotify_permissions_versions
  ORDER BY
    id DESC
  LIMIT 1)
  INSERT INTO spotify_tokens(
    user_id,
    encrypted_access_token,
    access_token_expiry,
    encrypted_refresh_token,
    permissions_version)
  SELECT
    $1,
    $2,
    $3,
    $4,
    id
  FROM
    latest_perm_version
  ON CONFLICT ON CONSTRAINT spotify_tokens_user_id_key
    DO UPDATE SET
      encrypted_access_token = $2,
      access_token_expiry = $3,
      encrypted_refresh_token = $4
    WHERE
      spotify_tokens.user_id = $1
`

type UserUpdateSpotifyTokensParams struct {
	UserID                uuid.UUID `json:"user_id"`
	EncryptedAccessToken  []byte    `json:"encrypted_access_token"`
	AccessTokenExpiry     time.Time `json:"access_token_expiry"`
	EncryptedRefreshToken []byte    `json:"encrypted_refresh_token"`
}

func (q *Queries) UserUpdateSpotifyTokens(ctx context.Context, arg UserUpdateSpotifyTokensParams) error {
	_, err := q.db.Exec(ctx, userUpdateSpotifyTokens,
		arg.UserID,
		arg.EncryptedAccessToken,
		arg.AccessTokenExpiry,
		arg.EncryptedRefreshToken,
	)
	return err
}

const userValidatePassword = `-- name: UserValidatePassword :one
SELECT
  (encrypted_password = crypt($1, encrypted_password))
FROM
  user_passwords AS up
  JOIN users u ON u.id = up.user_id
    AND UPPER(u.username) = UPPER($2::text)
`

type UserValidatePasswordParams struct {
	UserPass string `json:"user_pass"`
	Username string `json:"username"`
}

func (q *Queries) UserValidatePassword(ctx context.Context, arg UserValidatePasswordParams) (bool, error) {
	row := q.db.QueryRow(ctx, userValidatePassword, arg.UserPass, arg.Username)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const usersToFetchHistory = `-- name: UsersToFetchHistory :many
SELECT
  u.id, u.username, u.display_name, u.spotify_account, u.spotify_name, u.spotify_image_url, u.created
FROM
  users u
  JOIN spotify_tokens st ON u.id = st.user_id
    AND st.permissions_version >= 3
`

func (q *Queries) UsersToFetchHistory(ctx context.Context) ([]*User, error) {
	rows, err := q.db.Query(ctx, usersToFetchHistory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.DisplayName,
			&i.SpotifyAccount,
			&i.SpotifyName,
			&i.SpotifyImageUrl,
			&i.Created,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
