// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: queries.sql

package gen

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const getSpotifyTokensByRoomCode = `-- name: GetSpotifyTokensByRoomCode :one
SELECT
    st.encrypted_access_token,
    st.access_token_expiry,
    st.encrypted_refresh_token
FROM
    spotify_tokens AS st
    JOIN rooms AS r ON r.code = $1
        AND st.user_id = r.host_id
`

type GetSpotifyTokensByRoomCodeRow struct {
	EncryptedAccessToken  []byte    `json:"encrypted_access_token"`
	AccessTokenExpiry     time.Time `json:"access_token_expiry"`
	EncryptedRefreshToken []byte    `json:"encrypted_refresh_token"`
}

func (q *Queries) GetSpotifyTokensByRoomCode(ctx context.Context, code string) (*GetSpotifyTokensByRoomCodeRow, error) {
	row := q.db.QueryRowContext(ctx, getSpotifyTokensByRoomCode, code)
	var i GetSpotifyTokensByRoomCodeRow
	err := row.Scan(&i.EncryptedAccessToken, &i.AccessTokenExpiry, &i.EncryptedRefreshToken)
	return &i, err
}

const historyGetAlbumStreamsByYear = `-- name: HistoryGetAlbumStreamsByYear :many
SELECT
    album_name,
    COUNT(*) AS occurrences
FROM
    spotify_history
WHERE
    user_id = $1
    AND ms_played >= $2
    AND (
        skipped != true
        OR $3 :: boolean
    )
    AND timestamp BETWEEN ($4 :: int || '-01-01 00:00:00') :: timestamp
    AND (
        cast((($4 :: int) + 1) as text) || '-01-01 00:00:00'
    ) :: timestamp
GROUP BY
    album_name
ORDER BY
    COUNT(*) DESC
LIMIT
    35
`

type HistoryGetAlbumStreamsByYearParams struct {
	UserID       uuid.UUID `json:"user_id"`
	MinMsPlayed  int32     `json:"min_ms_played"`
	IncludeSkips bool      `json:"include_skips"`
	Year         int32     `json:"year"`
}

type HistoryGetAlbumStreamsByYearRow struct {
	AlbumName   string `json:"album_name"`
	Occurrences int64  `json:"occurrences"`
}

func (q *Queries) HistoryGetAlbumStreamsByYear(ctx context.Context, arg HistoryGetAlbumStreamsByYearParams) ([]*HistoryGetAlbumStreamsByYearRow, error) {
	rows, err := q.db.QueryContext(ctx, historyGetAlbumStreamsByYear,
		arg.UserID,
		arg.MinMsPlayed,
		arg.IncludeSkips,
		arg.Year,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*HistoryGetAlbumStreamsByYearRow
	for rows.Next() {
		var i HistoryGetAlbumStreamsByYearRow
		if err := rows.Scan(&i.AlbumName, &i.Occurrences); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const historyGetAll = `-- name: HistoryGetAll :many
SELECT
    TIMESTAMP,
    TRACK_NAME,
    ARTIST_NAME,
    album_name,
    MS_PLAYED,
    spotify_track_uri
FROM
    SPOTIFY_HISTORY
WHERE
    user_id = $1
    AND ms_played >= $2
    AND (
        skipped != true
        OR $3 :: boolean
    )
ORDER BY
    timestamp ASC
`

type HistoryGetAllParams struct {
	UserID       uuid.UUID `json:"user_id"`
	MinMsPlayed  int32     `json:"min_ms_played"`
	IncludeSkips bool      `json:"include_skips"`
}

type HistoryGetAllRow struct {
	Timestamp       time.Time `json:"timestamp"`
	TrackName       string    `json:"track_name"`
	ArtistName      string    `json:"artist_name"`
	AlbumName       string    `json:"album_name"`
	MsPlayed        int32     `json:"ms_played"`
	SpotifyTrackUri string    `json:"spotify_track_uri"`
}

func (q *Queries) HistoryGetAll(ctx context.Context, arg HistoryGetAllParams) ([]*HistoryGetAllRow, error) {
	rows, err := q.db.QueryContext(ctx, historyGetAll, arg.UserID, arg.MinMsPlayed, arg.IncludeSkips)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*HistoryGetAllRow
	for rows.Next() {
		var i HistoryGetAllRow
		if err := rows.Scan(
			&i.Timestamp,
			&i.TrackName,
			&i.ArtistName,
			&i.AlbumName,
			&i.MsPlayed,
			&i.SpotifyTrackUri,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const historyGetArtistStreamsByYear = `-- name: HistoryGetArtistStreamsByYear :many
SELECT
    artist_name,
    COUNT(*) AS occurrences
FROM
    spotify_history
WHERE
    user_id = $1
    AND ms_played >= $2
    AND (
        skipped != true
        OR $3 :: boolean
    )
    AND timestamp BETWEEN ($4 :: int || '-01-01 00:00:00') :: timestamp
    AND (
        cast((($4 :: int) + 1) as text) || '-01-01 00:00:00'
    ) :: timestamp
GROUP BY
    artist_name
ORDER BY
    COUNT(*) DESC
LIMIT
    35
`

type HistoryGetArtistStreamsByYearParams struct {
	UserID       uuid.UUID `json:"user_id"`
	MinMsPlayed  int32     `json:"min_ms_played"`
	IncludeSkips bool      `json:"include_skips"`
	Year         int32     `json:"year"`
}

type HistoryGetArtistStreamsByYearRow struct {
	ArtistName  string `json:"artist_name"`
	Occurrences int64  `json:"occurrences"`
}

func (q *Queries) HistoryGetArtistStreamsByYear(ctx context.Context, arg HistoryGetArtistStreamsByYearParams) ([]*HistoryGetArtistStreamsByYearRow, error) {
	rows, err := q.db.QueryContext(ctx, historyGetArtistStreamsByYear,
		arg.UserID,
		arg.MinMsPlayed,
		arg.IncludeSkips,
		arg.Year,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*HistoryGetArtistStreamsByYearRow
	for rows.Next() {
		var i HistoryGetArtistStreamsByYearRow
		if err := rows.Scan(&i.ArtistName, &i.Occurrences); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const historyGetByURI = `-- name: HistoryGetByURI :many
SELECT
    TIMESTAMP,
    TRACK_NAME,
    ARTIST_NAME,
    album_name,
    MS_PLAYED,
    spotify_track_uri
FROM
    SPOTIFY_HISTORY
WHERE
    user_id = $1
    AND ms_played >= $2
    AND (
        skipped != true
        OR $3 :: boolean
    )
    AND spotify_track_uri = $4
ORDER BY
    timestamp ASC
`

type HistoryGetByURIParams struct {
	UserID       uuid.UUID `json:"user_id"`
	MinMsPlayed  int32     `json:"min_ms_played"`
	IncludeSkips bool      `json:"include_skips"`
	Uri          string    `json:"uri"`
}

type HistoryGetByURIRow struct {
	Timestamp       time.Time `json:"timestamp"`
	TrackName       string    `json:"track_name"`
	ArtistName      string    `json:"artist_name"`
	AlbumName       string    `json:"album_name"`
	MsPlayed        int32     `json:"ms_played"`
	SpotifyTrackUri string    `json:"spotify_track_uri"`
}

func (q *Queries) HistoryGetByURI(ctx context.Context, arg HistoryGetByURIParams) ([]*HistoryGetByURIRow, error) {
	rows, err := q.db.QueryContext(ctx, historyGetByURI,
		arg.UserID,
		arg.MinMsPlayed,
		arg.IncludeSkips,
		arg.Uri,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*HistoryGetByURIRow
	for rows.Next() {
		var i HistoryGetByURIRow
		if err := rows.Scan(
			&i.Timestamp,
			&i.TrackName,
			&i.ArtistName,
			&i.AlbumName,
			&i.MsPlayed,
			&i.SpotifyTrackUri,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const historyGetTimestampRange = `-- name: HistoryGetTimestampRange :one
SELECT
    MIN(timestamp) :: timestamp AS first,
    MAX(timestamp) :: timestamp AS last
FROM
    spotify_history
WHERE
    user_id = $1
`

type HistoryGetTimestampRangeRow struct {
	First time.Time `json:"first"`
	Last  time.Time `json:"last"`
}

func (q *Queries) HistoryGetTimestampRange(ctx context.Context, userID uuid.UUID) (*HistoryGetTimestampRangeRow, error) {
	row := q.db.QueryRowContext(ctx, historyGetTimestampRange, userID)
	var i HistoryGetTimestampRangeRow
	err := row.Scan(&i.First, &i.Last)
	return &i, err
}

const historyGetTrackStreamsByYear = `-- name: HistoryGetTrackStreamsByYear :many
SELECT
    track_name,
    COUNT(*) AS occurrences
FROM
    spotify_history
WHERE
    user_id = $1
    AND ms_played >= $2
    AND (
        skipped != true
        OR $3 :: boolean
    )
    AND timestamp BETWEEN ($4 :: int || '-01-01 00:00:00') :: timestamp
    AND (
        cast((($4 :: int) + 1) as text) || '-01-01 00:00:00'
    ) :: timestamp
GROUP BY
    track_name
ORDER BY
    COUNT(*) DESC
LIMIT
    35
`

type HistoryGetTrackStreamsByYearParams struct {
	UserID       uuid.UUID `json:"user_id"`
	MinMsPlayed  int32     `json:"min_ms_played"`
	IncludeSkips bool      `json:"include_skips"`
	Year         int32     `json:"year"`
}

type HistoryGetTrackStreamsByYearRow struct {
	TrackName   string `json:"track_name"`
	Occurrences int64  `json:"occurrences"`
}

func (q *Queries) HistoryGetTrackStreamsByYear(ctx context.Context, arg HistoryGetTrackStreamsByYearParams) ([]*HistoryGetTrackStreamsByYearRow, error) {
	rows, err := q.db.QueryContext(ctx, historyGetTrackStreamsByYear,
		arg.UserID,
		arg.MinMsPlayed,
		arg.IncludeSkips,
		arg.Year,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*HistoryGetTrackStreamsByYearRow
	for rows.Next() {
		var i HistoryGetTrackStreamsByYearRow
		if err := rows.Scan(&i.TrackName, &i.Occurrences); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const historyInsertBulk = `-- name: HistoryInsertBulk :exec
INSERT INTO
    SPOTIFY_HISTORY(
        user_id,
        timestamp,
        platform,
        ms_played,
        conn_country,
        ip_addr,
        user_agent,
        track_name,
        artist_name,
        album_name,
        spotify_track_uri,
        reason_start,
        reason_end,
        shuffle,
        skipped,
        offline,
        offline_timestamp,
        incognito_mode
    )
VALUES
    (
        unnest($1 :: UUID []),
        unnest($2 :: TIMESTAMP []),
        unnest($3 :: TEXT []),
        unnest($4 :: INTEGER []),
        unnest($5 :: TEXT []),
        unnest($6 :: TEXT []),
        unnest($7 :: TEXT []),
        unnest($8 :: TEXT []),
        unnest($9 :: TEXT []),
        unnest($10 :: TEXT []),
        unnest($11 :: TEXT []),
        unnest($12 :: TEXT []),
        unnest($13 :: TEXT []),
        unnest($14 :: BOOLEAN []),
        unnest($15 :: BOOLEAN []),
        unnest($16 :: BOOLEAN []),
        unnest($17 :: TIMESTAMP []),
        unnest($18 :: BOOLEAN [])
    ) ON CONFLICT DO NOTHING
`

type HistoryInsertBulkParams struct {
	UserIds          []uuid.UUID `json:"user_ids"`
	Timestamp        []time.Time `json:"timestamp"`
	Platform         []string    `json:"platform"`
	MsPlayed         []int32     `json:"ms_played"`
	ConnCountry      []string    `json:"conn_country"`
	IpAddr           []string    `json:"ip_addr"`
	UserAgent        []string    `json:"user_agent"`
	TrackName        []string    `json:"track_name"`
	ArtistName       []string    `json:"artist_name"`
	AlbumName        []string    `json:"album_name"`
	SpotifyTrackUri  []string    `json:"spotify_track_uri"`
	ReasonStart      []string    `json:"reason_start"`
	ReasonEnd        []string    `json:"reason_end"`
	Shuffle          []bool      `json:"shuffle"`
	Skipped          []bool      `json:"skipped"`
	Offline          []bool      `json:"offline"`
	OfflineTimestamp []time.Time `json:"offline_timestamp"`
	IncognitoMode    []bool      `json:"incognito_mode"`
}

func (q *Queries) HistoryInsertBulk(ctx context.Context, arg HistoryInsertBulkParams) error {
	_, err := q.db.ExecContext(ctx, historyInsertBulk,
		pq.Array(arg.UserIds),
		pq.Array(arg.Timestamp),
		pq.Array(arg.Platform),
		pq.Array(arg.MsPlayed),
		pq.Array(arg.ConnCountry),
		pq.Array(arg.IpAddr),
		pq.Array(arg.UserAgent),
		pq.Array(arg.TrackName),
		pq.Array(arg.ArtistName),
		pq.Array(arg.AlbumName),
		pq.Array(arg.SpotifyTrackUri),
		pq.Array(arg.ReasonStart),
		pq.Array(arg.ReasonEnd),
		pq.Array(arg.Shuffle),
		pq.Array(arg.Skipped),
		pq.Array(arg.Offline),
		pq.Array(arg.OfflineTimestamp),
		pq.Array(arg.IncognitoMode),
	)
	return err
}

const historyInsertOne = `-- name: HistoryInsertOne :exec
INSERT INTO
    SPOTIFY_HISTORY(
        user_id,
        timestamp,
        platform,
        ms_played,
        conn_country,
        ip_addr,
        user_agent,
        track_name,
        artist_name,
        album_name,
        spotify_track_uri,
        reason_start,
        reason_end,
        shuffle,
        skipped,
        offline,
        offline_timestamp,
        incognito_mode
    )
VALUES
    (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        $10,
        $11,
        $12,
        $13,
        $14,
        $15,
        $16,
        $17,
        $18
    )
`

type HistoryInsertOneParams struct {
	UserID           uuid.UUID      `json:"user_id"`
	Timestamp        time.Time      `json:"timestamp"`
	Platform         string         `json:"platform"`
	MsPlayed         int32          `json:"ms_played"`
	ConnCountry      string         `json:"conn_country"`
	IpAddr           sql.NullString `json:"ip_addr"`
	UserAgent        sql.NullString `json:"user_agent"`
	TrackName        string         `json:"track_name"`
	ArtistName       string         `json:"artist_name"`
	AlbumName        string         `json:"album_name"`
	SpotifyTrackUri  string         `json:"spotify_track_uri"`
	ReasonStart      sql.NullString `json:"reason_start"`
	ReasonEnd        sql.NullString `json:"reason_end"`
	Shuffle          bool           `json:"shuffle"`
	Skipped          sql.NullBool   `json:"skipped"`
	Offline          bool           `json:"offline"`
	OfflineTimestamp sql.NullTime   `json:"offline_timestamp"`
	IncognitoMode    bool           `json:"incognito_mode"`
}

func (q *Queries) HistoryInsertOne(ctx context.Context, arg HistoryInsertOneParams) error {
	_, err := q.db.ExecContext(ctx, historyInsertOne,
		arg.UserID,
		arg.Timestamp,
		arg.Platform,
		arg.MsPlayed,
		arg.ConnCountry,
		arg.IpAddr,
		arg.UserAgent,
		arg.TrackName,
		arg.ArtistName,
		arg.AlbumName,
		arg.SpotifyTrackUri,
		arg.ReasonStart,
		arg.ReasonEnd,
		arg.Shuffle,
		arg.Skipped,
		arg.Offline,
		arg.OfflineTimestamp,
		arg.IncognitoMode,
	)
	return err
}

const roomAddMember = `-- name: RoomAddMember :exec
INSERT INTO room_members(user_id, room_id)
    VALUES ($1, $2)
`

type RoomAddMemberParams struct {
	UserID uuid.UUID `json:"user_id"`
	RoomID uuid.UUID `json:"room_id"`
}

func (q *Queries) RoomAddMember(ctx context.Context, arg RoomAddMemberParams) error {
	_, err := q.db.ExecContext(ctx, roomAddMember, arg.UserID, arg.RoomID)
	return err
}

const roomAddMemberByUsername = `-- name: RoomAddMemberByUsername :one
INSERT INTO room_members(user_id, room_id, is_moderator)
SELECT
    u.id,
    $1,
    $3
FROM
    users u
WHERE
    u.username = $2
RETURNING
    id
`

type RoomAddMemberByUsernameParams struct {
	RoomID      uuid.UUID `json:"room_id"`
	Username    string    `json:"username"`
	IsModerator bool      `json:"is_moderator"`
}

func (q *Queries) RoomAddMemberByUsername(ctx context.Context, arg RoomAddMemberByUsernameParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, roomAddMemberByUsername, arg.RoomID, arg.Username, arg.IsModerator)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const roomDeleteByID = `-- name: RoomDeleteByID :exec
DELETE FROM rooms r
WHERE r.code = $1
`

func (q *Queries) RoomDeleteByID(ctx context.Context, code string) error {
	_, err := q.db.ExecContext(ctx, roomDeleteByID, code)
	return err
}

const roomGetAllGuests = `-- name: RoomGetAllGuests :many
SELECT
    rg.name,
    rg.id,
    CASE WHEN counts.queued_tracks IS NOT NULL THEN
        counts.queued_tracks
    ELSE
        0
    END AS queued_tracks
FROM
    room_guests AS rg
    LEFT JOIN (
        SELECT
            guest_id,
            COUNT(*) AS queued_tracks
        FROM
            room_queue_tracks
        GROUP BY
            guest_id) counts ON rg.id = counts.guest_id
WHERE
    rg.room_id = $1
`

type RoomGetAllGuestsRow struct {
	Name         string    `json:"name"`
	ID           uuid.UUID `json:"id"`
	QueuedTracks int32     `json:"queued_tracks"`
}

func (q *Queries) RoomGetAllGuests(ctx context.Context, roomID uuid.UUID) ([]*RoomGetAllGuestsRow, error) {
	rows, err := q.db.QueryContext(ctx, roomGetAllGuests, roomID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*RoomGetAllGuestsRow
	for rows.Next() {
		var i RoomGetAllGuestsRow
		if err := rows.Scan(&i.Name, &i.ID, &i.QueuedTracks); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const roomGetAllMembers = `-- name: RoomGetAllMembers :many
SELECT
    u.id AS user_id,
    u.username,
    u.display_name,
    u.spotify_name,
    u.spotify_image_url,
    m.is_moderator,
    CASE WHEN counts.queued_tracks IS NOT NULL THEN
        counts.queued_tracks
    ELSE
        0
    END AS queued_tracks
FROM
    room_members AS m
    JOIN users u ON m.user_id = u.id
        AND m.room_id = $1
    LEFT JOIN (
        SELECT
            user_id,
            COUNT(*) AS queued_tracks
        FROM
            room_queue_tracks
        GROUP BY
            user_id) counts ON u.id = counts.user_id
`

type RoomGetAllMembersRow struct {
	UserID          uuid.UUID      `json:"user_id"`
	Username        string         `json:"username"`
	DisplayName     string         `json:"display_name"`
	SpotifyName     sql.NullString `json:"spotify_name"`
	SpotifyImageUrl sql.NullString `json:"spotify_image_url"`
	IsModerator     bool           `json:"is_moderator"`
	QueuedTracks    int32          `json:"queued_tracks"`
}

func (q *Queries) RoomGetAllMembers(ctx context.Context, roomID uuid.UUID) ([]*RoomGetAllMembersRow, error) {
	rows, err := q.db.QueryContext(ctx, roomGetAllMembers, roomID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*RoomGetAllMembersRow
	for rows.Next() {
		var i RoomGetAllMembersRow
		if err := rows.Scan(
			&i.UserID,
			&i.Username,
			&i.DisplayName,
			&i.SpotifyName,
			&i.SpotifyImageUrl,
			&i.IsModerator,
			&i.QueuedTracks,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const roomGetByCode = `-- name: RoomGetByCode :one
SELECT
    r.id,
    r.name,
    r.host_id,
    u.username AS host_username,
    u.display_name AS host_display,
    u.spotify_name AS host_spotify_name,
    u.spotify_image_url AS host_image,
    r.code,
    r.created
FROM
    rooms AS r
    JOIN users AS u ON r.code = $1
        AND u.id = r.host_id
`

type RoomGetByCodeRow struct {
	ID              uuid.UUID      `json:"id"`
	Name            string         `json:"name"`
	HostID          uuid.UUID      `json:"host_id"`
	HostUsername    string         `json:"host_username"`
	HostDisplay     string         `json:"host_display"`
	HostSpotifyName sql.NullString `json:"host_spotify_name"`
	HostImage       sql.NullString `json:"host_image"`
	Code            string         `json:"code"`
	Created         time.Time      `json:"created"`
}

func (q *Queries) RoomGetByCode(ctx context.Context, code string) (*RoomGetByCodeRow, error) {
	row := q.db.QueryRowContext(ctx, roomGetByCode, code)
	var i RoomGetByCodeRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.HostID,
		&i.HostUsername,
		&i.HostDisplay,
		&i.HostSpotifyName,
		&i.HostImage,
		&i.Code,
		&i.Created,
	)
	return &i, err
}

const roomGetHostID = `-- name: RoomGetHostID :one
SELECT
    r.host_id
FROM
    rooms r
WHERE
    r.code = $1
`

func (q *Queries) RoomGetHostID(ctx context.Context, code string) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, roomGetHostID, code)
	var host_id uuid.UUID
	err := row.Scan(&host_id)
	return host_id, err
}

const roomGetIDByCode = `-- name: RoomGetIDByCode :one
SELECT
    id
FROM
    rooms
WHERE (code = $1)
`

func (q *Queries) RoomGetIDByCode(ctx context.Context, code string) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, roomGetIDByCode, code)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const roomGetQueueTracks = `-- name: RoomGetQueueTracks :many
SELECT
    track_id,
    g.name AS guest_name,
    u.display_name AS member_name,
    timestamp,
    played
FROM
    room_queue_tracks t
    LEFT JOIN room_guests g ON g.id = t.guest_id
    LEFT JOIN users u ON u.id = t.user_id
WHERE
    t.room_id = $1
ORDER BY
    timestamp DESC
`

type RoomGetQueueTracksRow struct {
	TrackID    string         `json:"track_id"`
	GuestName  sql.NullString `json:"guest_name"`
	MemberName sql.NullString `json:"member_name"`
	Timestamp  time.Time      `json:"timestamp"`
	Played     bool           `json:"played"`
}

func (q *Queries) RoomGetQueueTracks(ctx context.Context, roomID uuid.UUID) ([]*RoomGetQueueTracksRow, error) {
	rows, err := q.db.QueryContext(ctx, roomGetQueueTracks, roomID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*RoomGetQueueTracksRow
	for rows.Next() {
		var i RoomGetQueueTracksRow
		if err := rows.Scan(
			&i.TrackID,
			&i.GuestName,
			&i.MemberName,
			&i.Timestamp,
			&i.Played,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const roomGuestGetName = `-- name: RoomGuestGetName :one
SELECT
    name
FROM
    room_guests
WHERE
    room_id = $1
    AND id = $2::uuid
`

type RoomGuestGetNameParams struct {
	RoomID  uuid.UUID `json:"room_id"`
	GuestID uuid.UUID `json:"guest_id"`
}

func (q *Queries) RoomGuestGetName(ctx context.Context, arg RoomGuestGetNameParams) (string, error) {
	row := q.db.QueryRowContext(ctx, roomGuestGetName, arg.RoomID, arg.GuestID)
	var name string
	err := row.Scan(&name)
	return name, err
}

const roomGuestInsert = `-- name: RoomGuestInsert :one
INSERT INTO room_guests(room_id, name)
SELECT
    r.id,
    $1
FROM
    rooms AS r
WHERE
    r.code = $2::text
RETURNING
    id,
    name
`

type RoomGuestInsertParams struct {
	Name     string `json:"name"`
	RoomCode string `json:"room_code"`
}

type RoomGuestInsertRow struct {
	ID   uuid.UUID `json:"id"`
	Name string    `json:"name"`
}

func (q *Queries) RoomGuestInsert(ctx context.Context, arg RoomGuestInsertParams) (*RoomGuestInsertRow, error) {
	row := q.db.QueryRowContext(ctx, roomGuestInsert, arg.Name, arg.RoomCode)
	var i RoomGuestInsertRow
	err := row.Scan(&i.ID, &i.Name)
	return &i, err
}

const roomGuestInsertWithID = `-- name: RoomGuestInsertWithID :one
INSERT INTO room_guests(id, room_id, name)
SELECT
    $2::uuid,
    r.id,
    $1
FROM
    rooms AS r
WHERE
    r.code = $3::text
RETURNING
    id,
    name
`

type RoomGuestInsertWithIDParams struct {
	Name     string    `json:"name"`
	GuestID  uuid.UUID `json:"guest_id"`
	RoomCode string    `json:"room_code"`
}

type RoomGuestInsertWithIDRow struct {
	ID   uuid.UUID `json:"id"`
	Name string    `json:"name"`
}

func (q *Queries) RoomGuestInsertWithID(ctx context.Context, arg RoomGuestInsertWithIDParams) (*RoomGuestInsertWithIDRow, error) {
	row := q.db.QueryRowContext(ctx, roomGuestInsertWithID, arg.Name, arg.GuestID, arg.RoomCode)
	var i RoomGuestInsertWithIDRow
	err := row.Scan(&i.ID, &i.Name)
	return &i, err
}

const roomInsertWithPassword = `-- name: RoomInsertWithPassword :one
WITH new_room AS (
INSERT INTO rooms(name, host_id)
        VALUES ($1, $2)
    RETURNING
        id, name, host_id, code, created
), new_pass AS (
INSERT INTO room_passwords(room_id, encrypted_password)
    SELECT
        id,
        crypt($3, gen_salt('bf'))
    FROM
        new_room
)
SELECT
    id, name, host_id, code, created
FROM
    new_room
`

type RoomInsertWithPasswordParams struct {
	Name     string    `json:"name"`
	HostID   uuid.UUID `json:"host_id"`
	RoomPass string    `json:"room_pass"`
}

type RoomInsertWithPasswordRow struct {
	ID      uuid.UUID `json:"id"`
	Name    string    `json:"name"`
	HostID  uuid.UUID `json:"host_id"`
	Code    string    `json:"code"`
	Created time.Time `json:"created"`
}

func (q *Queries) RoomInsertWithPassword(ctx context.Context, arg RoomInsertWithPasswordParams) (*RoomInsertWithPasswordRow, error) {
	row := q.db.QueryRowContext(ctx, roomInsertWithPassword, arg.Name, arg.HostID, arg.RoomPass)
	var i RoomInsertWithPasswordRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.HostID,
		&i.Code,
		&i.Created,
	)
	return &i, err
}

const roomMarkTracksAsPlayed = `-- name: RoomMarkTracksAsPlayed :exec
UPDATE
    room_queue_tracks
SET
    played = TRUE
WHERE
    room_id = $1
    AND timestamp <= $2
`

type RoomMarkTracksAsPlayedParams struct {
	RoomID    uuid.UUID `json:"room_id"`
	Timestamp time.Time `json:"timestamp"`
}

func (q *Queries) RoomMarkTracksAsPlayed(ctx context.Context, arg RoomMarkTracksAsPlayedParams) error {
	_, err := q.db.ExecContext(ctx, roomMarkTracksAsPlayed, arg.RoomID, arg.Timestamp)
	return err
}

const roomRemoveMember = `-- name: RoomRemoveMember :exec
DELETE FROM room_members rm
WHERE rm.room_id = $1
    AND rm.user_id = $2
`

type RoomRemoveMemberParams struct {
	RoomID uuid.UUID `json:"room_id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) RoomRemoveMember(ctx context.Context, arg RoomRemoveMemberParams) error {
	_, err := q.db.ExecContext(ctx, roomRemoveMember, arg.RoomID, arg.UserID)
	return err
}

const roomSetGuestQueueTrack = `-- name: RoomSetGuestQueueTrack :exec
INSERT INTO room_queue_tracks(track_id, guest_id, room_id)
SELECT
    $1,
    $2::uuid,
    r.id
FROM
    rooms AS r
WHERE
    r.code = $3::text
`

type RoomSetGuestQueueTrackParams struct {
	TrackID  string    `json:"track_id"`
	GuestID  uuid.UUID `json:"guest_id"`
	RoomCode string    `json:"room_code"`
}

func (q *Queries) RoomSetGuestQueueTrack(ctx context.Context, arg RoomSetGuestQueueTrackParams) error {
	_, err := q.db.ExecContext(ctx, roomSetGuestQueueTrack, arg.TrackID, arg.GuestID, arg.RoomCode)
	return err
}

const roomSetIsOpen = `-- name: RoomSetIsOpen :exec
UPDATE
    rooms
SET
    is_open = $2
WHERE
    id = $1
`

type RoomSetIsOpenParams struct {
	ID     uuid.UUID `json:"id"`
	IsOpen bool      `json:"is_open"`
}

func (q *Queries) RoomSetIsOpen(ctx context.Context, arg RoomSetIsOpenParams) error {
	_, err := q.db.ExecContext(ctx, roomSetIsOpen, arg.ID, arg.IsOpen)
	return err
}

const roomSetMemberQueueTrack = `-- name: RoomSetMemberQueueTrack :exec
INSERT INTO room_queue_tracks(track_id, user_id, room_id)
SELECT
    $1,
    $2::uuid,
    r.id
FROM
    rooms AS r
WHERE
    r.code = $3::text
`

type RoomSetMemberQueueTrackParams struct {
	TrackID  string    `json:"track_id"`
	UserID   uuid.UUID `json:"user_id"`
	RoomCode string    `json:"room_code"`
}

func (q *Queries) RoomSetMemberQueueTrack(ctx context.Context, arg RoomSetMemberQueueTrackParams) error {
	_, err := q.db.ExecContext(ctx, roomSetMemberQueueTrack, arg.TrackID, arg.UserID, arg.RoomCode)
	return err
}

const roomSetModerator = `-- name: RoomSetModerator :exec
UPDATE
    room_members
SET
    is_moderator = $3
WHERE
    room_id = $1
    AND user_id = $2
`

type RoomSetModeratorParams struct {
	RoomID      uuid.UUID `json:"room_id"`
	UserID      uuid.UUID `json:"user_id"`
	IsModerator bool      `json:"is_moderator"`
}

func (q *Queries) RoomSetModerator(ctx context.Context, arg RoomSetModeratorParams) error {
	_, err := q.db.ExecContext(ctx, roomSetModerator, arg.RoomID, arg.UserID, arg.IsModerator)
	return err
}

const roomUpdatePassword = `-- name: RoomUpdatePassword :exec
UPDATE
    room_passwords
SET
    encrypted_password = crypt($2, gen_salt('bf'))
WHERE
    room_id = $1
`

type RoomUpdatePasswordParams struct {
	RoomID   uuid.UUID `json:"room_id"`
	RoomPass string    `json:"room_pass"`
}

func (q *Queries) RoomUpdatePassword(ctx context.Context, arg RoomUpdatePasswordParams) error {
	_, err := q.db.ExecContext(ctx, roomUpdatePassword, arg.RoomID, arg.RoomPass)
	return err
}

const roomUpdateSpotifyTokens = `-- name: RoomUpdateSpotifyTokens :exec
UPDATE
    spotify_tokens st
SET
    encrypted_access_token = $2,
    access_token_expiry = $3,
    encrypted_refresh_token = $4
FROM
    rooms AS r
WHERE
    st.user_id = r.host_id
    AND r.code = $1
`

type RoomUpdateSpotifyTokensParams struct {
	Code                  string    `json:"code"`
	EncryptedAccessToken  []byte    `json:"encrypted_access_token"`
	AccessTokenExpiry     time.Time `json:"access_token_expiry"`
	EncryptedRefreshToken []byte    `json:"encrypted_refresh_token"`
}

func (q *Queries) RoomUpdateSpotifyTokens(ctx context.Context, arg RoomUpdateSpotifyTokensParams) error {
	_, err := q.db.ExecContext(ctx, roomUpdateSpotifyTokens,
		arg.Code,
		arg.EncryptedAccessToken,
		arg.AccessTokenExpiry,
		arg.EncryptedRefreshToken,
	)
	return err
}

const roomUserIsMember = `-- name: RoomUserIsMember :one
SELECT
    is_moderator
FROM
    room_members
WHERE
    user_id = $1
    AND room_id = $2
`

type RoomUserIsMemberParams struct {
	UserID uuid.UUID `json:"user_id"`
	RoomID uuid.UUID `json:"room_id"`
}

func (q *Queries) RoomUserIsMember(ctx context.Context, arg RoomUserIsMemberParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, roomUserIsMember, arg.UserID, arg.RoomID)
	var is_moderator bool
	err := row.Scan(&is_moderator)
	return is_moderator, err
}

const roomValidatePassword = `-- name: RoomValidatePassword :one
SELECT
    (encrypted_password = crypt($2::text, encrypted_password::text))
FROM
    room_passwords AS rp
    JOIN rooms r ON r.id = rp.room_id
        AND r.code = $1
`

type RoomValidatePasswordParams struct {
	Code     string `json:"code"`
	RoomPass string `json:"room_pass"`
}

func (q *Queries) RoomValidatePassword(ctx context.Context, arg RoomValidatePasswordParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, roomValidatePassword, arg.Code, arg.RoomPass)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const userDeleteSpotifyInfo = `-- name: UserDeleteSpotifyInfo :exec
UPDATE
    users
SET
    spotify_account = NULL,
    spotify_name = NULL,
    spotify_image_url = NULL
WHERE
    id = $1
`

func (q *Queries) UserDeleteSpotifyInfo(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, userDeleteSpotifyInfo, id)
	return err
}

const userGetByID = `-- name: UserGetByID :one
SELECT
    id,
    username,
    display_name,
    spotify_account,
    spotify_name,
    spotify_image_url
FROM
    users u
WHERE
    id = $1
`

type UserGetByIDRow struct {
	ID              uuid.UUID      `json:"id"`
	Username        string         `json:"username"`
	DisplayName     string         `json:"display_name"`
	SpotifyAccount  sql.NullString `json:"spotify_account"`
	SpotifyName     sql.NullString `json:"spotify_name"`
	SpotifyImageUrl sql.NullString `json:"spotify_image_url"`
}

func (q *Queries) UserGetByID(ctx context.Context, id uuid.UUID) (*UserGetByIDRow, error) {
	row := q.db.QueryRowContext(ctx, userGetByID, id)
	var i UserGetByIDRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.DisplayName,
		&i.SpotifyAccount,
		&i.SpotifyName,
		&i.SpotifyImageUrl,
	)
	return &i, err
}

const userGetByUsername = `-- name: UserGetByUsername :one
SELECT
    id,
    username,
    display_name,
    spotify_account,
    spotify_name,
    spotify_image_url
FROM
    users u
WHERE
    username = $1
`

type UserGetByUsernameRow struct {
	ID              uuid.UUID      `json:"id"`
	Username        string         `json:"username"`
	DisplayName     string         `json:"display_name"`
	SpotifyAccount  sql.NullString `json:"spotify_account"`
	SpotifyName     sql.NullString `json:"spotify_name"`
	SpotifyImageUrl sql.NullString `json:"spotify_image_url"`
}

func (q *Queries) UserGetByUsername(ctx context.Context, username string) (*UserGetByUsernameRow, error) {
	row := q.db.QueryRowContext(ctx, userGetByUsername, username)
	var i UserGetByUsernameRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.DisplayName,
		&i.SpotifyAccount,
		&i.SpotifyName,
		&i.SpotifyImageUrl,
	)
	return &i, err
}

const userGetHostedRooms = `-- name: UserGetHostedRooms :many
SELECT
    r.id,
    r.name,
    r.code,
    r.created,
    u.id AS host_id,
    u.username AS host_username,
    u.display_name AS host_display_name,
    u.spotify_image_url AS host_spotify_image_url
FROM
    rooms r
    JOIN users u ON r.host_id = u.id
        AND u.id = $1
        AND r.is_open = $2
`

type UserGetHostedRoomsParams struct {
	ID     uuid.UUID `json:"id"`
	IsOpen bool      `json:"is_open"`
}

type UserGetHostedRoomsRow struct {
	ID                  uuid.UUID      `json:"id"`
	Name                string         `json:"name"`
	Code                string         `json:"code"`
	Created             time.Time      `json:"created"`
	HostID              uuid.UUID      `json:"host_id"`
	HostUsername        string         `json:"host_username"`
	HostDisplayName     string         `json:"host_display_name"`
	HostSpotifyImageUrl sql.NullString `json:"host_spotify_image_url"`
}

func (q *Queries) UserGetHostedRooms(ctx context.Context, arg UserGetHostedRoomsParams) ([]*UserGetHostedRoomsRow, error) {
	rows, err := q.db.QueryContext(ctx, userGetHostedRooms, arg.ID, arg.IsOpen)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*UserGetHostedRoomsRow
	for rows.Next() {
		var i UserGetHostedRoomsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Code,
			&i.Created,
			&i.HostID,
			&i.HostUsername,
			&i.HostDisplayName,
			&i.HostSpotifyImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const userGetJoinedRooms = `-- name: UserGetJoinedRooms :many
SELECT
    r.id,
    r.name,
    r.code,
    r.created,
    u.id AS host_id,
    u.username AS host_username,
    u.display_name AS host_display_name,
    u.spotify_image_url AS host_spotify_image_url
FROM
    rooms r
    JOIN room_members rm ON rm.user_id = $1
        AND r.id = rm.room_id
        AND r.is_open = $2
    JOIN users u ON r.host_id = u.id
`

type UserGetJoinedRoomsParams struct {
	UserID uuid.UUID `json:"user_id"`
	IsOpen bool      `json:"is_open"`
}

type UserGetJoinedRoomsRow struct {
	ID                  uuid.UUID      `json:"id"`
	Name                string         `json:"name"`
	Code                string         `json:"code"`
	Created             time.Time      `json:"created"`
	HostID              uuid.UUID      `json:"host_id"`
	HostUsername        string         `json:"host_username"`
	HostDisplayName     string         `json:"host_display_name"`
	HostSpotifyImageUrl sql.NullString `json:"host_spotify_image_url"`
}

func (q *Queries) UserGetJoinedRooms(ctx context.Context, arg UserGetJoinedRoomsParams) ([]*UserGetJoinedRoomsRow, error) {
	rows, err := q.db.QueryContext(ctx, userGetJoinedRooms, arg.UserID, arg.IsOpen)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*UserGetJoinedRoomsRow
	for rows.Next() {
		var i UserGetJoinedRoomsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Code,
			&i.Created,
			&i.HostID,
			&i.HostUsername,
			&i.HostDisplayName,
			&i.HostSpotifyImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const userGetSpotifyTokens = `-- name: UserGetSpotifyTokens :one
SELECT
    st.encrypted_access_token,
    st.access_token_expiry,
    st.encrypted_refresh_token
FROM
    spotify_tokens AS st
    WHERE st.user_id = $1
`

type UserGetSpotifyTokensRow struct {
	EncryptedAccessToken  []byte    `json:"encrypted_access_token"`
	AccessTokenExpiry     time.Time `json:"access_token_expiry"`
	EncryptedRefreshToken []byte    `json:"encrypted_refresh_token"`
}

func (q *Queries) UserGetSpotifyTokens(ctx context.Context, userID uuid.UUID) (*UserGetSpotifyTokensRow, error) {
	row := q.db.QueryRowContext(ctx, userGetSpotifyTokens, userID)
	var i UserGetSpotifyTokensRow
	err := row.Scan(&i.EncryptedAccessToken, &i.AccessTokenExpiry, &i.EncryptedRefreshToken)
	return &i, err
}

const userHasSpotifyHistory = `-- name: UserHasSpotifyHistory :one
SELECT
    EXISTS (SELECT user_id, timestamp, platform, ms_played, conn_country, ip_addr, user_agent, track_name, artist_name, album_name, spotify_track_uri, reason_start, reason_end, shuffle, skipped, offline, offline_timestamp, incognito_mode FROM SPOTIFY_HISTORY WHERE USER_ID = $1)
`

func (q *Queries) UserHasSpotifyHistory(ctx context.Context, userID uuid.UUID) (bool, error) {
	row := q.db.QueryRowContext(ctx, userHasSpotifyHistory, userID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const userInsertWithPassword = `-- name: UserInsertWithPassword :one
WITH new_user AS (
INSERT INTO users(username, display_name)
        VALUES ($1, $2)
    RETURNING
        id, username, display_name, created)
    INSERT INTO user_passwords(user_id, encrypted_password)
    SELECT
        id,
        crypt($3, gen_salt('bf'))
    FROM
        new_user
    RETURNING (
        SELECT
            id
        FROM
            new_user)
`

type UserInsertWithPasswordParams struct {
	Username    string `json:"username"`
	DisplayName string `json:"display_name"`
	UserPass    string `json:"user_pass"`
}

func (q *Queries) UserInsertWithPassword(ctx context.Context, arg UserInsertWithPasswordParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, userInsertWithPassword, arg.Username, arg.DisplayName, arg.UserPass)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const userUpdatePassword = `-- name: UserUpdatePassword :exec
UPDATE
    users
SET
    encrypted_password = crypt($1, gen_salt('bf'))
WHERE
    id = $2
`

type UserUpdatePasswordParams struct {
	UserPass string    `json:"user_pass"`
	UserID   uuid.UUID `json:"user_id"`
}

func (q *Queries) UserUpdatePassword(ctx context.Context, arg UserUpdatePasswordParams) error {
	_, err := q.db.ExecContext(ctx, userUpdatePassword, arg.UserPass, arg.UserID)
	return err
}

const userUpdateSpotifyInfo = `-- name: UserUpdateSpotifyInfo :exec
UPDATE
    users
SET
    spotify_account = $2,
    spotify_name = $3,
    spotify_image_url = $4
WHERE
    id = $1
`

type UserUpdateSpotifyInfoParams struct {
	ID              uuid.UUID      `json:"id"`
	SpotifyAccount  sql.NullString `json:"spotify_account"`
	SpotifyName     sql.NullString `json:"spotify_name"`
	SpotifyImageUrl sql.NullString `json:"spotify_image_url"`
}

func (q *Queries) UserUpdateSpotifyInfo(ctx context.Context, arg UserUpdateSpotifyInfoParams) error {
	_, err := q.db.ExecContext(ctx, userUpdateSpotifyInfo,
		arg.ID,
		arg.SpotifyAccount,
		arg.SpotifyName,
		arg.SpotifyImageUrl,
	)
	return err
}

const userUpdateSpotifyTokens = `-- name: UserUpdateSpotifyTokens :exec
INSERT INTO spotify_tokens(user_id, encrypted_access_token, access_token_expiry, encrypted_refresh_token)
    VALUES ($1, $2, $3, $4)
ON CONFLICT ON CONSTRAINT spotify_tokens_user_id_key
    DO UPDATE SET
        encrypted_access_token = $2, access_token_expiry = $3, encrypted_refresh_token = $4
    WHERE
        spotify_tokens.user_id = $1
`

type UserUpdateSpotifyTokensParams struct {
	UserID                uuid.UUID `json:"user_id"`
	EncryptedAccessToken  []byte    `json:"encrypted_access_token"`
	AccessTokenExpiry     time.Time `json:"access_token_expiry"`
	EncryptedRefreshToken []byte    `json:"encrypted_refresh_token"`
}

func (q *Queries) UserUpdateSpotifyTokens(ctx context.Context, arg UserUpdateSpotifyTokensParams) error {
	_, err := q.db.ExecContext(ctx, userUpdateSpotifyTokens,
		arg.UserID,
		arg.EncryptedAccessToken,
		arg.AccessTokenExpiry,
		arg.EncryptedRefreshToken,
	)
	return err
}

const userValidatePassword = `-- name: UserValidatePassword :one
SELECT
    (encrypted_password = crypt($1, encrypted_password))
FROM
    user_passwords AS up
    JOIN users u ON u.id = up.user_id
        AND UPPER(u.username) = UPPER($2::text)
`

type UserValidatePasswordParams struct {
	UserPass string `json:"user_pass"`
	Username string `json:"username"`
}

func (q *Queries) UserValidatePassword(ctx context.Context, arg UserValidatePasswordParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, userValidatePassword, arg.UserPass, arg.Username)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}
